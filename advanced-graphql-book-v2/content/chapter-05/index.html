<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <link rel="icon" href="../../images/favicon.ico" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mandi Wise" />
  <title>Advanced GraphQL with Apollo</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../../css/web.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div id="masthead">
<div class="close-button-wrapper">
<button id="masthead-close" type="button"><span>Close</span></button>
</div>
<header id="title-block-header">
<h1 class="title">Advanced GraphQL with Apollo</h1>
<p class="subtitle">Build a Distributed GraphQL API with Apollo Federation 2 and Apollo Server</p>
<p class="author">Mandi Wise</p>
</header>
<nav class="book-nav">
<ol class="front-matter-content">
<li><a href="../preface/index.html">Preface</a></li>
</ol>
<ol class="main-matter-content">
<li><a href="../chapter-01/index.html">Apollo Federation and Gateway</a></li>
<li><a href="../chapter-02/index.html">Authentication and User Account Management with Auth0</a></li>
<li><a href="../chapter-03/index.html">Apollo Data Sources, Custom Scalars, and Custom Directives</a></li>
<li><a href="../chapter-04/index.html">User Metadata Management with MongoDB and Mongoose</a></li>
<li><a href="../chapter-05/index.html">Relay-Style Pagination</a></li>
<li><a href="../chapter-06/index.html">Bookmark Management with MongoDB and Mongoose</a></li>
<li><a href="../chapter-07/index.html">API Performance and Security Considerations</a></li>
<li><a href="../chapter-08/index.html">Multi-Subgraph Workflows with Temporal</a></li>
<li><a href="../chapter-09/index.html">Managed Federation with Apollo Studio</a></li>
<li><a href="../chapter-10/index.html">Apollo Router</a></li>
</ol>
<ol class="back-matter-content">
<li><a href="../about-the-author/index.html">About the Author</a></li>
<li><a href="../changelog/index.html">Changelog</a></li>
</ol>
<img src="../../images/8bp-logo-white.svg" class="logo" alt="8-Bit Press Inc. logo" />
</nav>
</div>
<div id="chapter">
<div class="chapter-nav">
<nav id="TOC" role="doc-toc">
<button id="masthead-open" type="button"><span>Book Navigation</span></button>
<h2 id="toc-title">Contents</h2>
<ul>
<li><a href="#relay-style-pagination">Chapter 5: Relay-Style Pagination</a>
<ul>
<li><a href="#pagination-primer">Pagination Primer</a></li>
<li><a href="#relay-style-pagination-internals">Relay-Style Pagination Internals</a></li>
<li><a href="#add-pagination-types-to-the-profiles-service">Add Pagination Types to the Profiles Service</a></li>
<li><a href="#create-a-pagination-class-for-mongodb-data">Create a <code>Pagination</code> Class for MongoDB Data</a></li>
<li><a href="#add-forward-pagination-to-the-network-field">Add Forward Pagination to the <code>network</code> Field</a></li>
<li><a href="#add-backward-pagination-to-the-network-field">Add Backward Pagination to the <code>network</code> Field</a></li>
<li><a href="#generate-the-pageinfo-to-include-in-the-response">Generate the <code>PageInfo</code> to Include in the Response</a></li>
<li><a href="#add-pagination-to-profiles-and-searchprofiles-fields">Add Pagination to <code>profiles</code> and <code>searchProfiles</code> Fields</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
</ul>
</nav>
</div>
<div class="content">
<h1 id="relay-style-pagination">Chapter 5: Relay-Style Pagination</h1>
<div class="boxout">
<p>In this chapter, we will:</p>
<ul>
<li>Explore Relay-style pagination and its algorithms</li>
<li>Create a <code>Pagination</code> class to implement Relay-style pagination on documents fetched from MongoDB</li>
<li>Add pagination to the <code>network</code> field on the <code>Profile</code> type</li>
<li>Add pagination to the <code>profiles</code> and <code>searchProfiles</code> queries</li>
</ul>
</div>
<h2 id="pagination-primer">Pagination Primer</h2>
<p>As far as “good problems to have” go, at some point, we would hope that enough users are active on Marked that it will no longer be feasible to retrieve the entire list of user profiles for the <code>profiles</code> or <code>searchProfiles</code> queries or the full list of <code>network</code> members associated with a profile all at once. This is where pagination comes in. From now on, where long lists of data may be queried we will limit the number of results initially retrieved from MongoDB, but allow users to fetch more pages of results with subsequent requests.</p>
<p>While pagination can be easy to take for granted in the apps we use every day, it is often one of the trickiest things to reason about and implement properly. Relay-style pagination is no exception, and it requires additional considerations to ensure a GraphQL schema adheres to Relay’s opinionated specification.</p>
<p>Relay-style pagination certainly isn’t the only option for paginating results with a GraphQL API either. Before we jump into implementing pagination in Marked, let’s explore different styles of pagination that we could consider using here.</p>
<h3 id="offset-based">Offset-Based</h3>
<p>Historically, offset-based pagination has been a popular choice for paginating results from a database. With offset-based pagination, a client provides information about the number of results it wants to receive per page (called the <em>limit</em>) and how many results to skip before retrieving the limited number of items (called the <em>offset</em>). The server uses these criteria to query the database for that specific set of results (setting a default limit and offset, if necessary).</p>
<p>To visualize how offset-based pagination works, imagine you have a dataset with five items in it and you want to retrieve the second page of those items sorted in descending order with a limit of two items per page:</p>
<p><img src="../../images/diagrams/offset-pagination.png" class="center-no-caption" alt="Diagram of basic offset-based pagination" /></p>
<p>Offset-based pagination is useful when you need to know the total number of pages available. It can also easily support <em>bi-directional</em> pagination. Bi-directional pagination allows you to jump back and forth between pages or to navigate to a specific page within the results. This is the kind of navigation typically seen on blogs.</p>
<p>However, there can be performance downsides to this approach if the queried database has a lot of records in it. Further, if new records are added to the database at a high frequency, then the page <em>window</em> may become mismatched with real-time reality, resulting in duplicate or missed records in the pages of results. To illustrate this pitfall, imagine retrieving the first page of results from our dataset. While you’re browsing those results, a new sixth item is added before requesting the second page. Suddenly, the paging window shifts back one position, and the fourth item will now confusingly appear at the end of the first page and the start of the second page:</p>
<p><img src="../../images/diagrams/offset-pagination-add-new.png" class="center-no-caption" alt="Diagram of page window confusion with offset-based pagination" /></p>
<h3 id="cursor-based">Cursor-Based</h3>
<p>Cursor-based pagination uses (surprise!) a <em>cursor</em> to progress through results in a dataset. A cursor is a pointer to a specific result in a dataset and can be anything that makes sense to the back-end application as long as it’s a unique, sequential value. As a client navigates through subsequent pages, the server returns results after the item denoted by the cursor value.</p>
<p>Cursor-based pagination on our five-item dataset—once again in descending order with two items per page—can be visualized as follows:</p>
<p><img src="../../images/diagrams/cursor-pagination.png" class="center-no-caption" alt="Diagram of cursor-based pagination" /></p>
<p>The nature of the cursor itself is inconsequential to the client—the client just needs to send this value back to the server on subsequent requests so the server knows from which point it should retrieve more results.</p>
<p>Cursor-based pagination is well-suited to datasets updated at high velocities because it helps address the issue of page window inaccuracies that can happen with offset-based pagination. If a sixth item is added to our dataset after retrieving the first page, then there will be no confusion about where to start the second page when using a cursor:</p>
<p><img src="../../images/diagrams/cursor-pagination-add-new.png" class="center-no-caption" alt="Diagram of cursor-based pagination correctly handling the next page when new items are added" /></p>
<p>This style of pagination does have its trade-offs though. A cursor-based approach has the downside of not providing any way to jump to a specific page number or calculate the total number of pages. However, if you’re building an app that will be updated rapidly and with infinite scrolling implemented in the user interface to browse content, then the lack of numbered pages and total page counts likely won’t be deal-breakers for you.</p>
<h3 id="relay-style">Relay-Style</h3>
<p>Relay-style pagination is an opinionated flavor of cursor-based pagination for GraphQL APIs. Relay itself is a JavaScript framework that can be used as a client to retrieve and cache data from a GraphQL API. It was created by Facebook and was designed with Facebook-level applications in mind. In other words, it works well for apps with lots of data in lists that are read and written at a high velocity.</p>
<p>Relay’s barriers to entry are a bit higher than other GraphQL client libraries such as Apollo Client, so Relay itself often isn’t the first package developers reach for when getting started with GraphQL. However, Relay offers a useful methodology for how to handle paginated data in GraphQL APIs in what it calls a <a href="https://facebook.github.io/relay/graphql/connections.htm">cursor connection specification</a>.</p>
<p>We’ll opt for using Relay-style pagination in the Marked GraphQL API because it will be instructive to see how to implement it from scratch and it will also make our API more future-friendly if any clients using Relay wish to make requests to our GraphQL API in the future.</p>
<p>An important thing to keep in mind with Relay-style pagination is that it is <em>uni-directional</em> by design. If you need to implement “Previous Page” and “Next Page” buttons to traverse content in an app, then Relay-style pagination probably won’t work well for you (although a quick Google search will reveal some proposed workarounds for supporting bi-directional paging with Relay). However, if your user interface requires infinite scrolling to load additional pages of results, then this approach will be a good fit for you.</p>
<p>As we will see, Relay is very opinionated about how pagination requests are made via field arguments as well as how the paginated lists of data are output from the operations. Here’s an example of what a query would look like for a single user with this kind of pagination applied to the <code>network</code> field:</p>
<p></p>
<div class="code-context">
<p>GraphQL Query</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">query</span> <span class="p">{</span>
  <span class="k">profile</span><span class="p">(</span>username: <span class="s2">&quot;marksalot&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">fullName</span>
    <span class="k">network</span><span class="p">(</span>first: <span class="mi">20</span>, after: <span class="s2">&quot;someProfileId&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">edges</span> <span class="p">{</span>
        <span class="k">cursor</span>
        <span class="k">node</span> <span class="p">{</span>
          <span class="k">fullName</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">pageInfo</span> <span class="p">{</span>
        <span class="k">hasPreviousPage</span>
        <span class="k">hasNextPage</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>You may have noticed a few interesting aspects of this query. First, we have the <code>edges</code> field, which is a list containing the <code>edge</code> type. The <code>edge</code> type is an Object type with at least two fields called <code>node</code> and <code>cursor</code>. The <code>node</code> is the Object type itself and can be just about any GraphQL type except a list (for our case, it will be a <code>Profile</code> type). The <code>cursor</code> is a string that corresponds to the unique, sequential value that identifies the edge. Lastly, the <code>pageInfo</code> field returns an Object type that must contain at least <code>hasPreviousPage</code> and <code>hasNextPage</code> fields. These fields are both non-nullable Boolean types.</p>
<p>Also worth noting are the <code>first</code> and <code>after</code> arguments for the query—these are the <em>forward pagination</em> arguments. If we wanted to paginate backward, then we would use the <code>last</code> and <code>before</code> arguments.</p>
<div class="boxout">
<p><em>Backward pagination</em> is different from sorting results in descending order. Backward pagination means starting at what constitutes the end of a dataset and working back to the beginning. Sorting results in descending order means traversing pages of results from the item with the highest sort value to the lowest.</p>
<p>A dataset would typically be sorted first, and then would have forward or backward pagination applied to retrieve pages of sorted results. The diagrams in the next section will help to visualize these concepts.</p>
</div>
<p>What’s not obvious from the example query above is that at the top level a <em>connection type</em> would be implemented as an Object type (with the suffix <code>Connection</code> added to its name) and the <code>network</code> field would now return that single connection Object type instead of a list containing <code>Profile</code> types.</p>
<p>The query example above is exactly what we’ll be working toward first—we want to be able to paginate the list of profiles that represent members of a user’s network. Presumably, a user will connect with many other users over time and if we wanted to list all of the network members in a single view in the client application, then it wouldn’t be very efficient to try to load and display them all at once. Pagination will help solve this problem for us here and we’ll reuse much of the code we write for this field to paginate the <code>profiles</code> and <code>searchProfiles</code> queries, as well as a bookmark-related fields in the next chapter.</p>
<h2 id="relay-style-pagination-internals">Relay-Style Pagination Internals</h2>
<p>Relay has a pagination algorithm that describes how to evaluate pagination-related query arguments to return the correct edges in a response. Before implementing this algorithm in our code, we’re going to further explore the different elements of Relay-style pagination and how they work under the hood. First, when applying pagination the client is required to send us information describing how many results it wants, and potentially, where to begin extracting those results from the dataset.</p>
<p>Forward pagination arguments include:</p>
<ul>
<li><code>first</code>: The number of results to retrieve, counting forward (must be a non-negative integer)</li>
<li><code>after</code>: Start counting results after the item identified by this cursor (for example, a database ID)</li>
</ul>
<p>Backward pagination arguments include:</p>
<ul>
<li><code>last</code>: The number of results to retrieve, counting backward (also a non-negative integer)</li>
<li><code>before</code>: Start counting results before the item identified by this cursor (again, some meaningful, sequential identifier)</li>
</ul>
<p>Typically, we wouldn’t want a client to supply both <code>first</code> and <code>last</code> arguments. According to the specification:</p>
<blockquote>
<p>When both <code>first</code> and <code>last</code> are included, both of the fields should be set according to the above algorithms, but their meaning as it relates to pagination becomes unclear. This is among the reasons that pagination with both <code>first</code> and <code>last</code> is discouraged.</p>
</blockquote>
<p>Supplying both arguments could certainly be confusing. For example, what does it mean to simultaneously retrieve the first two and last three items from a dataset and within a single page window? To avoid this ambiguity, we’re going to throw an error if a client supplies both <code>first</code> and <code>last</code> arguments.</p>
<p>When an initial page of results is sent, the server enables the client to continue requesting additional pages of results by including the following information in the response:</p>
<ul>
<li>Whether a next page of results is available (required for forward pagination, optional for backward pagination if it can be efficiently calculated)</li>
<li>Whether a previous page of results is available (required for backward pagination, optional for forward pagination if it can be efficiently calculated)</li>
<li>The start cursor and end cursor values for this page (not required in the specification, but useful for clients to formulate their subsequent requests)</li>
</ul>
<p>With these points in mind, let’s now visualize how forward and backward pagination will work on our fictional dataset of five items with an <code>items</code> query, sorted in ascending and descending order while requesting two items per page.</p>
<h3 id="forward-pagination-with-ascending-sort-order">Forward Pagination with Ascending Sort Order</h3>
<p>We’ll start at the first item (overall, or after a specified cursor) and show items in ascending order:</p>
<p><img src="../../images/diagrams/relay-forward-ascending.png" class="center-no-caption" alt="Diagram of forward ascending pagination" /></p>
<p>Page 1 (<code>first: 2</code>):</p>
<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Page 2 (<code>first: 2</code> / <code>after: 2</code>):</p>
<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">3</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">4</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3 id="forward-pagination-with-descending-sort-order">Forward Pagination with Descending Sort Order</h3>
<p>We’ll start at the last item (overall, or after a specified cursor) and show items in descending order:</p>
<p><img src="../../images/diagrams/relay-forward-descending.png" class="center-no-caption" alt="Diagram of forward descending pagination" /></p>
<p>Page 1 (<code>first: 2</code>):</p>
<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">5</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">4</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Page 2 (<code>first: 2</code> / <code>after: 4</code>):</p>
<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">3</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3 id="backward-pagination-with-ascending-sort-order">Backward Pagination with Ascending Sort Order</h3>
<p>We’ll start at the last item (overall, or before a specified cursor) and show the items in ascending order:</p>
<p><img src="../../images/diagrams/relay-backward-ascending.png" class="center-no-caption" alt="Diagram of backward ascending pagination" /></p>
<p>Page 1 (<code>last: 2</code>):</p>
<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">4</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">5</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Page 2 (<code>last: 2</code> / <code>before: 4</code>):</p>
<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">3</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3 id="backward-pagination-with-descending-sort-order">Backward Pagination with Descending Sort Order</h3>
<p>We’ll start at the first item (overall, or before a specified cursor) and show items in descending order:</p>
<p><img src="../../images/diagrams/relay-backward-descending.png" class="center-no-caption" alt="Diagram of backward descending pagination" /></p>
<p>Page 1 (<code>last: 2</code>):</p>
<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Page 2 (<code>last: 2</code> / <code>before: 2</code>):</p>
<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;items&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">4</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="mi">3</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="add-pagination-types-to-the-profiles-service">Add Pagination Types to the Profiles Service</h2>
<p>Now that we have a mental model for how results should be returned in a paginated API response, we’ll begin refactoring part of the profiles service’s schema to add the new types required by Relay-style pagination. These new types include:</p>
<ul>
<li><code>ProfileConnection</code>: An Object type that will be returned for fields that require a paginated list of <code>Profile</code> types (contained within its <code>edges</code> field).</li>
<li><code>ProfileEdge</code>: An Object type that will contain <code>cursor</code> and <code>node</code> fields (and the <code>node</code> field will be a single <code>Profile</code>).</li>
<li><code>PageInfo</code>: An Object type containing the <code>hasPreviousPage</code> and <code>hasNextPage</code> fields required by Relay, as well as the <code>endCursor</code> and <code>startCursor</code> fields we’ll add for a client’s convenience (this type will be used across multiple subgraph schemas).</li>
</ul>
<p>As we refactor our code we’ll also add a field argument for sorting the list of user profiles. To begin, we’ll create the new <code>PageInfo</code> type in the profiles service’s schema:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/schema.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Singline"># ...</span>

<span class="hll"><span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="c c-Multi">Information about pagination in a connection.</span>
</span><span class="hll"><span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="kt">type</span> <span class="k">PageInfo</span> <span class="p">{</span>
</span><span class="hll">  <span class="s2">&quot;The cursor to continue from when paginating forward.&quot;</span>
</span><span class="hll">  endCursor: <span class="k">String</span>
</span><span class="hll">  <span class="s2">&quot;Whether there are more items when paginating forward.&quot;</span>
</span><span class="hll">  hasNextPage: <span class="k">Boolean</span><span class="p">!</span>
</span><span class="hll">  <span class="s2">&quot;Whether there are more items when paginating backward.&quot;</span>
</span><span class="hll">  hasPreviousPage: <span class="k">Boolean</span><span class="p">!</span>
</span><span class="hll">  <span class="s2">&quot;The cursor to continue from them paginating backward.&quot;</span>
</span><span class="hll">  startCursor: <span class="k">String</span>
</span><span class="hll"><span class="p">}</span>
</span><span class="hll">
</span><span class="c c-Singline"># ...</span>
</pre></div>

<p>Again, the <code>endCursor</code> and <code>startCursor</code> fields aren’t required in the <code>PageInfo</code> type in the Relay specification, but providing them here will be a nice convenience for clients so that they don’t have to calculate these document ID values manually based on the edges that are returned.</p>
<p>Before we move on, we should pause and think ahead to what the full API schema will look like after the bookmarks service is added in the next chapter. Ultimately, there will be bookmark-related fields that also require pagination so we will need to use the <code>PageInfo</code> type in that subgraph schema as well. That brings us to one significant difference between Federation 1 and Federation 2. In Apollo Federation lingo, a non-entity type that is shared among multiple subgraph schemas is known as a <em>value type</em>. In Federation 1, these non-entity types (which could be Scalar, Object, Interface, Input Object, Enum, and Union types) were sharable by default as long as they contained exactly the same fields. Although you may not have realized it at the time, we already made use of a value type in the accounts and profiles services by adding the custom <code>DateTime</code> Scalar to both.</p>
<p>With Federation 2, however, Object types cannot be shared by default. Instead, if you need to share an Object type between subgraphs, then you must import Federation 2’s <code>@shareable</code> directive and explicitly mark that type (or a sub-selection of its fields) as shareable. Let’s do that for the entire <code>PageInfo</code> type:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/schema.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">extend</span> <span class="k">schema</span>
<span class="hll">  <span class="kt">@link</span><span class="p">(</span>url: <span class="s2">&quot;https://specs.apollo.dev/federation/v2.0&quot;</span>,
</span><span class="hll">        import: <span class="p">[</span><span class="s2">&quot;@key&quot;, &quot;@shareable&quot;</span><span class="p">])</span>
</span>
<span class="c c-Singline"># ...</span>

<span class="c c-Multi">&quot;&quot;&quot;</span>
<span class="c c-Multi">Information about pagination in a connection.</span>
<span class="c c-Multi">&quot;&quot;&quot;</span>
<span class="hll"><span class="kt">type</span> <span class="k">PageInfo</span> <span class="kt">@shareable</span> <span class="p">{</span>
</span>  <span class="c c-Singline"># ...</span>
<span class="p">}</span>

<span class="c c-Singline"># ...</span>
</pre></div>

<p>This opt-in approach to sharing helps ensure that a subgraph that initially defines an Object type won’t find that this type has been used in unexpected ways in other subgraphs. It’s important to note that there’s nothing magical about the <code>@shareable</code> directive that will guarantee that the fields of this type are resolved consistently across all subgraphs that use it—as we discussed with the <code>DateTime</code> Scalar type, it’s up to the subgraph owners to ensure the field resolvers behave predictably across subgraphs.</p>
<div class="boxout">
<p><strong>More on Improved Value Type Ergonomics in Federation 2</strong></p>
<p>Beyond the <code>@shareable</code> directive, Federation 2 also allows Object types of the same name to differ in what fields they include and also differ in those fields’ nullability. This feature of the specification makes it easier to evolve these types if they are shared by many subgraphs and without necessitating a lockstep release for composition to succeed. Additionally, the <code>@inaccessible</code> can be used on new fields that are introduced in a shared Object type in one subgraph to exclude these fields from the API schema until other subgraphs provide support for them too.</p>
<p>Enum, Interface, and Union types can also be used more flexibly with Federation 2 as their definitions may differ between subgraphs (and no <code>@shareable</code> directive is required). Instead, Enum type values, Union type members, and Interface type fields will be merged during composition.</p>
<p>Please refer to the Apollo Federation documentation to learn more about <a href="https://www.apollographql.com/docs/federation/federated-types/sharing-types">the current nuances of value type usage</a>.</p>
</div>
<p>Next, we’ll add the <code>ProfileConnection</code> and <code>ProfileEdge</code> types:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/schema.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Singline"># ...</span>

<span class="hll"><span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="c c-Multi">A list of profile edges with pagination information.</span>
</span><span class="hll"><span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="kt">type</span> <span class="k">ProfileConnection</span> <span class="p">{</span>
</span><span class="hll">  <span class="s2">&quot;A list of profile edges.&quot;</span>
</span><span class="hll">  edges: <span class="p">[</span><span class="k">ProfileEdge</span><span class="p">]</span>
</span><span class="hll">  <span class="s2">&quot;Information to assist with pagination.&quot;</span>
</span><span class="hll">  pageInfo: <span class="k">PageInfo</span><span class="p">!</span>
</span><span class="hll"><span class="p">}</span>
</span><span class="hll">
</span><span class="hll"><span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="c c-Multi">A single profile node with its cursor.</span>
</span><span class="hll"><span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="kt">type</span> <span class="k">ProfileEdge</span> <span class="p">{</span>
</span><span class="hll">  <span class="s2">&quot;A cursor for use in pagination.&quot;</span>
</span><span class="hll">  cursor: <span class="k">ID</span><span class="p">!</span>
</span><span class="hll">  <span class="s2">&quot;A profile at the end of an edge.&quot;</span>
</span><span class="hll">  node: <span class="k">Profile</span><span class="p">!</span>
</span><span class="hll"><span class="p">}</span>
</span><span class="hll">
</span><span class="c c-Singline"># ...</span>
</pre></div>

<p>We’ll need to add one more thing to the schema to sort the network profiles in ascending or descending order via a field argument. To facilitate sorting, we’ll define our first Enum type called <code>ProfileOrderBy</code> to help limit the sorting field to either usernames or creation time only, and either ascending or descending alphabetically:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/schema.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Singline"># ...</span>

<span class="hll"><span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="c c-Multi">Sorting options for profile connections.</span>
</span><span class="hll"><span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="k">enum</span> <span class="k">ProfileOrderBy</span> <span class="p">{</span>
</span><span class="hll">  <span class="s2">&quot;Order profiles ascending by creation time.&quot;</span>
</span><span class="hll">  <span class="k">CREATED_AT_ASC</span>
</span><span class="hll">  <span class="s2">&quot;Order profiles descending by creation time.&quot;</span>
</span><span class="hll">  <span class="k">CREATED_AT_DESC</span>
</span><span class="hll">  <span class="s2">&quot;Order profiles ascending by username.&quot;</span>
</span><span class="hll">  <span class="k">USERNAME_ASC</span>
</span><span class="hll">  <span class="s2">&quot;Order profiles descending by username.&quot;</span>
</span><span class="hll">  <span class="k">USERNAME_DESC</span>
</span><span class="hll"><span class="p">}</span>
</span><span class="hll">
</span><span class="c c-Singline"># ...</span>
</pre></div>

<p>The first portion of the existing schema that we’ll refactor to use the pagination-related types will be the <code>network</code> field on the <code>Profile</code> type:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/schema.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Singline"># ...</span>

<span class="c c-Multi">&quot;&quot;&quot;</span>
<span class="c c-Multi">A profile contains metadata about a specific user.</span>
<span class="c c-Multi">&quot;&quot;&quot;</span>
<span class="kt">type</span> <span class="k">Profile</span> <span class="kt">@key</span><span class="p">(</span>fields: <span class="s2">&quot;id&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="c c-Singline"># ...</span>
  <span class="s2">&quot;Other users that have been added to the user&#39;s network.&quot;</span>
<span class="hll">  <span class="k">network</span> <span class="p">(</span>
</span><span class="hll">    first: <span class="k">Int</span>
</span><span class="hll">    after: <span class="k">String</span>
</span><span class="hll">    last: <span class="k">Int</span>
</span><span class="hll">    before: <span class="k">String</span>
</span><span class="hll">    orderBy: <span class="k">ProfileOrderBy</span> <span class="p">=</span> <span class="k">USERNAME_ASC</span>
</span><span class="hll">  <span class="p">):</span> <span class="k">ProfileConnection</span>
</span>  <span class="c c-Singline"># ...</span>
<span class="p">}</span>

<span class="c c-Singline"># ...</span>
</pre></div>

<p>The <code>ProfileOrderByInput</code> is an optional variable. If it’s not provided, we’ll set the default sort order to be ascending by username. The use of a default value for the <code>orderBy</code> argument is noteworthy because it guarantees that a value for this argument will be available in the field resolver while still allowing this field to be nullable. We could have also applied a default value at runtime, but defining the default in the schema makes this behavior more transparent to client developers.</p>
<p>Also note that the type we expect to receive back for this field is now a single <code>ProfileConnection</code>, rather than a list of <code>Profile</code> types, which means it will no longer be a simple array of profiles, but rather an object with the following shape:</p>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;profile&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
      <span class="nt">&quot;network&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;coolUserInMyNetwork&quot;</span>
            <span class="p">},</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;5d06de0941b23b1f0ccc7911&quot;</span>
          <span class="p">}</span>
        <span class="p">],</span>
        <span class="nt">&quot;pageInfo&quot;</span><span class="p">:</span> <span class="p">{</span>
          <span class="nt">&quot;startCursor&quot;</span><span class="p">:</span> <span class="s2">&quot;5d06de0941b23b1f0ccc7911&quot;</span><span class="p">,</span>
          <span class="nt">&quot;endCursor&quot;</span><span class="p">:</span> <span class="s2">&quot;5d06de0941b23b1f0ccc7911&quot;</span><span class="p">,</span>
          <span class="nt">&quot;hasNextPage&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nt">&quot;hasPreviousPage&quot;</span><span class="p">:</span> <span class="kc">false</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Before we move on to update the resolver for the <code>network</code> field to return data in this shape, we need to figure out how to get paginated results like this from the database. First, we’ll write some helper functions to facilitate paginating results from MongoDB. Following that, we’ll need to update the <code>ProfilesDataSource</code> to use these helpers so that our resolvers can return the correct data in the right shape.</p>
<h2 id="create-a-pagination-class-for-mongodb-data">Create a <code>Pagination</code> Class for MongoDB Data</h2>
<p>Creating the functions that will facilitate paginating results from MongoDB will be one of the logically denser tasks we undertake while building this API. The payoff will be worthwhile—by the end of this chapter, we’ll have a working implementation of Relay-style pagination to use in other Marked subgraph services and also as a reference point for future projects.</p>
<p>The code we write to paginate the profiles will be generic enough that we can repurpose it in the bookmarks service later, so we’ll create a new file called <code>Pagination.js</code> in the <code>shared/src/utils</code> directory to contain the code for the <code>Pagination</code> class. In this class, we will define generalized methods that MongoDB-based data sources can use to retrieve pages of documents by a cursor. Let’s scaffold all the methods we’ll need here now:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">Model</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">Model</span> <span class="o">=</span> <span class="nx">Model</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Get documents and cast them into the correct edge/node shape</span>
  <span class="nx">async</span> <span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Get pagination information</span>
  <span class="nx">async</span> <span class="nx">getPageInfo</span><span class="p">(</span><span class="nx">edges</span><span class="p">,</span> <span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Add the cursor ID with the correct comparison operator to the query </span>
  <span class="c1">// filter</span>
  <span class="nx">async</span> <span class="nx">_getFilterWithCursor</span><span class="p">(</span><span class="nx">fromCursorId</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">operator</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Create the aggregation pipeline to paginate a full-text search</span>
  <span class="nx">async</span> <span class="nx">_getSearchPipeline</span><span class="p">(</span><span class="nx">fromCursorId</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">operator</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Reverse the sort direction when queries need to look in the opposite</span>
  <span class="c1">// direction of the set sort order (e.g. next/previous page checks)</span>
  <span class="nx">_reverseSortDirection</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Get the correct comparison operator based on the sort order</span>
  <span class="nx">_getOperator</span><span class="p">(</span><span class="nx">sort</span><span class="p">,</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{}</span>

  <span class="c1">// Determine if a query is a full-text search based on the sort </span>
  <span class="c1">// expression</span>
  <span class="nx">_isSearchQuery</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Check if a next page of results is available</span>
  <span class="nx">async</span> <span class="nx">_getHasNextPage</span><span class="p">(</span><span class="nx">endCursor</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Check if a previous page of results is available</span>
  <span class="nx">async</span> <span class="nx">_getHasPreviousPage</span><span class="p">(</span><span class="nx">startCursor</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Get the ID of the first document in the paging window</span>
  <span class="nx">_getStartCursor</span><span class="p">(</span><span class="nx">edges</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Get the ID of the last document in the paging window</span>
  <span class="nx">_getEndCursor</span><span class="p">(</span><span class="nx">edges</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>Again, we want this class to be repurposed, so we’ll pass a Mongoose model into the constructor when we instantiate a new <code>Pagination</code> object. The first two methods—<code>getEdges</code> and <code>getPages</code>—will be what an Apollo data source uses to fetch the required documents and page info for a given resolver. All of the other methods will be used internally by the class to support the work done in the first two methods.</p>
<p>There’s a lot happening in this file already, so let’s outline a high-level plan. First, we’ll work out how to retrieve edges and page info for forward pagination scenarios (where <code>first</code> is supplied as an argument). Next, we’ll update the <code>ProfilesDataSource</code> and resolvers to test out that code, and then we’ll deal with backward pagination scenarios (where <code>last</code> is supplied as an argument) and test those too. To begin, we’ll import <code>UserInputError</code> from <code>apollo-server</code> at the top of <code>Pagination.js</code> to help with error handling:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="hll"><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>
</span><span class="hll">
</span><span class="c1">// ...</span>
</pre></div>

<p>Next, we’ll plan out the <code>getEdges</code> method:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">async</span> <span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="kr">const</span> <span class="p">{</span>
</span><span class="hll">      <span class="nx">after</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">before</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">first</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">last</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">filter</span> <span class="o">=</span> <span class="p">{}</span>,
</span><span class="hll">      sort = <span class="p">{}</span>
</span><span class="hll">    <span class="p">}</span> <span class="o">=</span> <span class="nx">queryArgs</span><span class="p">;</span>
</span><span class="hll">    <span class="kd">let</span> <span class="nx">edges</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="c1">// handle user input errors...</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="c1">// forward pagination happens here</span>
</span><span class="hll">      <span class="c1">// edges = ???</span>
</span><span class="hll">    <span class="p">}</span> else <span class="p">{</span>
</span><span class="hll">      <span class="c1">// backward pagination happens here (later)</span>
</span><span class="hll">      <span class="c1">// edges = ???</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="nx">edges</span><span class="p">;</span>
</span><span class="hll">  <span class="p">}</span>
</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>This method has one parameter called <code>queryArgs</code>. The <code>queryArgs</code> will be an object containing the Relay-related pagination arguments, as well as inner <code>filter</code> and <code>sort</code> objects to help MongoDB pull the correct, ordered documents from the database. The method is set up with basic control flow to check if the query is requesting forward-paginated or backward-paginated documents. Before we attempt to pull any paginated results, we’ll do some error handling:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="p">{</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">before</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">filter</span> <span class="o">=</span> <span class="p">{}</span>, sort = <span class="p">{}</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">queryArgs</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">edges</span><span class="p">;</span>

<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">first</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">last</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span>
</span><span class="hll">        <span class="s2">&quot;Provide a `first` or `last` value to paginate this connection.&quot;</span>
</span><span class="hll">      <span class="p">);</span>
</span><span class="hll">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">&amp;&amp;</span> <span class="nx">last</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span>
</span><span class="hll">        <span class="s2">&quot;Passing `first` and `last` arguments is not supported with this connection.&quot;</span>
</span><span class="hll">      <span class="p">);</span>
</span><span class="hll">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">last</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span>
</span><span class="hll">        <span class="s2">&quot;Minimum record request for `first` and `last` arguments is 0.&quot;</span>
</span><span class="hll">      <span class="p">);</span>
</span><span class="hll">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">||</span> <span class="nx">last</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span>
</span><span class="hll">        <span class="s2">&quot;Maximum record request for `first` and `last` arguments is 100.&quot;</span>
</span><span class="hll">      <span class="p">);</span>
</span><span class="hll">    <span class="p">}</span>
</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>The <code>first</code> or <code>last</code> argument is key to understanding how the profiles must be paginated from the database, and we need one (and only one) of those arguments to get the correct documents from MongoDB. Correspondingly, we’ll throw an error if the client doesn’t supply a <code>first</code> or <code>last</code> argument, or if it supplies both <code>first</code> and <code>last</code> arguments. According to the Relay specification, we must also throw an error if the <code>first</code> or <code>last</code> argument supplied is less than <code>0</code>. For performance reasons we’ll also limit the maximum number of results a client can request at one time to <code>100</code>.</p>
<div class="boxout">
<p>The Relay Specification doesn’t say that supplying both <code>first</code> and <code>last</code> arguments is forbidden, but it does point out (twice) that this practice is strongly discouraged because it leads to ambiguous pagination query results. We’ll choose to throw an error if this occurs to avoid confusion.</p>
</div>
<p>Next, we’ll fetch documents when the <code>first</code> argument is available:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">      <span class="kr">const</span> <span class="nx">docs</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">filter</span><span class="p">)</span>
</span><span class="hll">        <span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span>
</span><span class="hll">        <span class="p">.</span><span class="nx">limit</span><span class="p">(</span><span class="nx">first</span><span class="p">)</span>
</span><span class="hll">        <span class="p">.</span><span class="nx">exec</span><span class="p">();</span>
</span><span class="hll">
</span><span class="hll">      <span class="nx">edges</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">length</span>
</span><span class="hll">        <span class="o">?</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">doc</span> <span class="p">=&gt;</span> <span class="p">({</span> <span class="nx">cursor</span><span class="o">:</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">_id</span><span class="p">,</span> <span class="nx">node</span><span class="o">:</span> <span class="nx">doc</span> <span class="p">}))</span>
</span><span class="hll">        <span class="o">:</span> <span class="p">[];</span>
</span>    <span class="p">}</span> else <span class="p">{</span>
      <span class="c1">// backward pagination happens here (later)</span>
      <span class="c1">// edges = ???</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>Note that we pass the <code>filter</code> object into the <code>find</code> method above to filter the selection of returned documents. Recall that we filter the <code>network</code> field on the <code>Profile</code> type by searching for applicable user account IDs as follows:</p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="nx">accountId</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$in</span><span class="o">:</span> <span class="p">[</span> <span class="s2">&quot;_id_1&quot;</span><span class="p">,</span> <span class="s2">&quot;_id_2&quot;</span><span class="p">,</span> <span class="p">...</span> <span class="p">]</span> <span class="p">}</span> <span class="p">}</span>
</pre></div>

<p>By using the <code>$in</code> operator here we are asking MongoDB to only return documents where the <code>accountId</code> field matches one of the account IDs in the provided array, which is exactly what we need—only return documents where the <code>accountId</code> matches one of the account IDs in the <code>network</code> array field of a given user profile document.</p>
<p>We also chain the <code>sort</code> method onto this and pass in the <code>sort</code> object, which by default will be <code>{username: 1}</code>, meaning that we want to sort by username in ascending order as a default. To sort by username in descending order, we would set <code>{username: -1}</code>. Next, we chain the <code>limit</code> method to only return the first N results, as specified by the <code>first</code> value. After retrieving the documents from MongoDB, we must <code>map</code> over the array of documents to produce a new array of objects with <code>cursor</code> and <code>node</code> properties so that they match the <code>ProfileEdge</code> shape.</p>
<p>At first glance, this may seem like all we need. If we only ever needed to retrieve the first page of results, then that would be the case. However, we must account for a client supplying the <code>after</code> argument for a paginated field. To do that we have to build out the <code>_getFilterWithCursor</code> method. This method will allow us to take the filter that is passed into <code>getEdges</code> via its <code>filter</code> parameter and combine it with another filter that only queries results after a specific document. The query document containing the combined filters will have this shape:</p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="nx">$and</span><span class="o">:</span> <span class="p">[</span>
  <span class="p">{</span> <span class="p">{</span> <span class="nx">accountId</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$in</span><span class="o">:</span> <span class="p">[</span> <span class="s2">&quot;_id_1&quot;</span><span class="p">,</span> <span class="s2">&quot;_id_2&quot;</span><span class="p">,</span> <span class="p">...</span> <span class="p">]</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span>,
  <span class="p">{</span> <span class="nx">username</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$gt</span><span class="o">:</span> <span class="s2">&quot;someuser&quot;</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">]}</span>
</pre></div>

<p>The <code>$gt</code> operator means <em>greater than</em> and will only get results <em>after</em> the document that contains the specified username. Later, we’ll also use the operator for <em>less than</em>, <code>$lt</code>, to look for results that occur <em>before</em> a specific username.</p>
<p>The <code>_getFilterWithCursor</code> method will look like this:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">async</span> <span class="nx">_getFilterWithCursor</span><span class="p">(</span><span class="nx">fromCursorId</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">operator</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="kd">let</span> <span class="nx">filterWithCursor</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">$and</span><span class="o">:</span> <span class="p">[</span><span class="nx">filter</span><span class="p">]</span> <span class="p">};</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">fieldArr</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">fieldArr</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span> <span class="nx">fieldArr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="s2">&quot;_id&quot;</span><span class="p">;</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">fromDoc</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">findOne</span><span class="p">({</span> <span class="nx">_id</span><span class="o">:</span> <span class="nx">fromCursorId</span> <span class="p">})</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="nx">field</span><span class="p">)</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">exec</span><span class="p">();</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fromDoc</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span><span class="sb">`No record found for ID &#39;</span><span class="si">${</span><span class="nx">fromCursorId</span><span class="si">}</span><span class="sb">&#39;`</span><span class="p">);</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">    <span class="nx">filterWithCursor</span><span class="p">.</span><span class="nx">$and</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
</span><span class="hll">      <span class="p">[</span><span class="nx">field</span><span class="p">]</span><span class="o">:</span> <span class="p">{</span> <span class="p">[</span><span class="nx">operator</span><span class="p">]</span><span class="o">:</span> <span class="nx">fromDoc</span><span class="p">[</span><span class="nx">field</span><span class="p">]</span> <span class="p">}</span>
</span><span class="hll">    <span class="p">});</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="nx">filterWithCursor</span><span class="p">;</span>
</span><span class="hll">  <span class="p">}</span>
</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>Note that this method has four parameters:</p>
<ul>
<li><code>fromCursorId</code>: Typically, this will be either the <code>after</code> or <code>before</code> value</li>
<li><code>filter</code>: An array containing the followed profile IDs</li>
<li><code>sort</code>: The MongoDB sort object</li>
<li><code>operator</code>: Specifies whether we want results <code>$lt</code> or <code>$gt</code> than the provided cursor ID</li>
</ul>
<p>Inside the method, we nest the original <code>filter</code> inside of an array within another object containing MongoDB’s <code>$and</code> logical operator as a key. We’ll push our cursor rule onto this array shortly. Next, we check if the <code>sort</code> object is not empty, and assign its single key (the <code>username</code> here) to the <code>field</code> variable. If it’s empty we just use the <code>_id</code> field by default.</p>
<p>After that, we need to get the document that matches <code>fromCursorId</code> on the <code>_id</code> field. If one can’t be found, then we throw an error because we won’t have anything to paginate against. If everything is OK, we push the additional filter onto the <code>$and</code> array and return the updated filter from the function. Note that we also chain on the <code>select</code> method before <code>exec</code> and pass it the <code>field</code> value as an argument because we don’t need to retrieve all of the fields in the <code>fromDoc</code>, just the one we use for sorting (the <code>_id</code> field will also be included by default unless we explicitly opt out of retrieving it). This is known as a <em>projection</em> in MongoDB.</p>
<p>Next, we have to build out the <code>_getOperator</code> method to get the correct operator to pass into <code>_getFilterWithCursor</code>:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">_getOperator</span><span class="p">(</span><span class="nx">sort</span><span class="p">,</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">orderArr</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">    <span class="k">return</span> <span class="nx">orderArr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">orderArr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="s2">&quot;$lt&quot;</span> <span class="o">:</span> <span class="s2">&quot;$gt&quot;</span><span class="p">;</span>
</span><span class="hll">  <span class="p">}</span>
</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>For now, what happens in this method will be straightforward—it checks if there are any values inside of the <code>sort</code> object, and if the value is <code>-1</code> the returned comparison operator is <code>$lt</code>, otherwise, it’s <code>$gt</code>. Later, we’ll need to create more advanced control flow here and make use of the <code>options</code> parameter when we add paginated results for full-text search queries.</p>
<p>Now we can update the <code>getEdges</code> method to handle an <code>after</code> argument to ensure we get the correct page of results after a cursor:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">      <span class="kr">const</span> <span class="nx">operator</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getOperator</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">      <span class="kr">const</span> <span class="nx">queryDoc</span> <span class="o">=</span> <span class="nx">after</span>
</span><span class="hll">        <span class="o">?</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getFilterWithCursor</span><span class="p">(</span><span class="nx">after</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">operator</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span>
</span><span class="hll">        <span class="o">:</span> <span class="nx">filter</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">      <span class="kr">const</span> <span class="nx">docs</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">queryDoc</span><span class="p">)</span>
</span>        <span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">limit</span><span class="p">(</span><span class="nx">first</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">exec</span><span class="p">();</span>

      <span class="nx">edges</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">length</span>
        <span class="o">?</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">doc</span> <span class="p">=&gt;</span> <span class="p">({</span> <span class="nx">cursor</span><span class="o">:</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">_id</span><span class="p">,</span> <span class="nx">node</span><span class="o">:</span> <span class="nx">doc</span> <span class="p">}))</span>
        <span class="o">:</span> <span class="p">[];</span>
    <span class="p">}</span> else <span class="p">{</span>
      <span class="c1">// backward pagination happens here (later)</span>
      <span class="c1">// edges = ???</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>In the code above, we generate the combined query document if <code>after</code> has a value, otherwise we’ll stick with the regular <code>filter</code> as a query document to get the first page of results. We also get the correct operator so when we pass in the new <code>queryDoc</code> value to the <code>find</code> method we will get results in the correct sort direction.</p>
<p>Before we move onto updating the <code>network</code> resolver and its related <code>ProfilesDataSource</code> method, we’ll set up the <code>getPageInfo</code> method to return some placeholder values for now:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">async</span> <span class="nx">getPageInfo</span><span class="p">(</span><span class="nx">edges</span><span class="p">,</span> <span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">return</span> <span class="p">{</span>
</span><span class="hll">      <span class="nx">hasNextPage</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">hasPreviousPage</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">startCursor</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">endCursor</span><span class="o">:</span> <span class="kc">null</span>
</span><span class="hll">    <span class="p">};</span>
</span><span class="hll">  <span class="p">}</span>
</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>We’ll fix this later when we get basic forward and backward pagination working. And as a final step, we’ll export the new <code>Pagination</code> class from the main entry point of the <code>shared</code> module:</p>
<p></p>
<div class="code-context">
<p>shared/src/index.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">authDirectives</span> <span class="nx">from</span> <span class="s2">&quot;./directives/authDirectives.js&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">DateTimeType</span> <span class="nx">from</span> <span class="s2">&quot;./scalars/DateTypeType.js&quot;</span><span class="p">;</span>
<span class="hll"><span class="kr">import</span> <span class="nx">Pagination</span> <span class="nx">from</span> <span class="s2">&quot;./utils/Pagination.js&quot;</span><span class="p">;</span>
</span>
<span class="hll"><span class="kr">export</span> <span class="p">{</span> <span class="nx">authDirectives</span><span class="p">,</span> <span class="nx">DateTimeType</span><span class="p">,</span> <span class="nx">Pagination</span> <span class="p">};</span>
</span></pre></div>

<h2 id="add-forward-pagination-to-the-network-field">Add Forward Pagination to the <code>network</code> Field</h2>
<p>Before moving forward, you’ll want to make sure that you have at least six user accounts and associated profiles created in Auth0 and MongoDB. Use the <code>createAccount</code> and <code>createProfile</code> mutations to create a few additional users if you haven’t done so already.</p>
<div class="boxout">
<p>To speed things up, you may want to temporarily remove the <code>@owner</code> directive for <code>createProfile</code> so that you don’t have to obtain an access token for each user account to create their profile. But be sure to reapply the directive when you’re done!</p>
</div>
<p>Once the users are created, make sure that one of your users has the other five users added to their network. You can use the <code>addToNetwork</code> query in Explorer to do this. Because we can’t use the API to query data on the <code>network</code> field until we finish refactoring its resolver in this section, you’ll have to check in MongoDB to make sure that you correctly followed the five other users. You can see five users added to the <code>network</code> field in first profile document in MongoDB Compass below:</p>
<p><img src="../../images/screenshots/mongo-network-members.png" alt="Five other users in another user’s network in MongoDB" /><br />
</p>
<div class="boxout">
<p>For reference, the usernames, Auth0 IDs, and profile document IDs of the five network members referenced in the examples throughout this chapter are:</p>
<p><code>ada_lovelace</code> | <code>auth0|625ed039359d0b006f4eb638</code> | <code>625ed5a652707218760b0122</code> <code>alan_turing</code> | <code>auth0|625ed0591109db006a6e67d8</code> | <code>625ed61552707218760b0124</code> <code>george_boole</code> | <code>auth0|625ed06e9b367400701f91d1</code> | <code>625ed64852707218760b0126</code> <code>grace_hopper</code> | <code>auth0|625ed0798e5ab40068ace5ae</code> | <code>625ed69a52707218760b0128</code> <code>margaret_hamilton</code> | <code>auth0|625ed0839b367400701f91da</code> | <code>625ed6c052707218760b012a</code></p>
<p>The order of the users listed above reflects the order in which they were added to MongoDB.</p>
</div>
<p>With our <code>Pagination</code> class sufficiently built out, we’ll import it into <code>ProfilesDataSource.js</code>:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/dataSources/ProfilesDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">DataSource</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-datasource&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="hll"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Pagination</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;../../../../shared/src/index.js&quot;</span><span class="p">;</span>
</span><span class="hll">
</span><span class="c1">// ...</span>
</pre></div>

<p>We’ll use it to create a new <code>Pagination</code> object, passing the <code>Profile</code> model into it:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/dataSources/ProfilesDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">class</span> <span class="nx">ProfilesDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">({</span> <span class="nx">Profile</span> <span class="p">})</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">Profile</span> <span class="o">=</span> <span class="nx">Profile</span><span class="p">;</span>
<span class="hll">    <span class="k">this</span><span class="p">.</span><span class="nx">pagination</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Pagination</span><span class="p">(</span><span class="nx">Profile</span><span class="p">);</span>
</span>  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">ProfilesDataSource</span><span class="p">;</span>
</pre></div>

<p>Now we can update the <code>getNetworkProfiles</code> method:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/dataSources/ProfilesDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">class</span> <span class="nx">ProfilesDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">async</span> <span class="nx">getNetworkProfiles</span><span class="p">({</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">before</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">orderBy</span><span class="p">,</span> <span class="nx">network</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">    <span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">sortArgs</span> <span class="o">=</span> <span class="nx">orderBy</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">);</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">direction</span> <span class="o">=</span> <span class="nx">sortArgs</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">sortArgs</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">arg</span> <span class="p">=&gt;</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">())</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">=&gt;</span>
</span><span class="hll">        <span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">arg</span> <span class="o">:</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">()</span> <span class="o">+</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class="hll">      <span class="p">)</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
</span><span class="hll">    <span class="nx">sort</span><span class="p">[</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="nx">direction</span> <span class="o">===</span> <span class="s2">&quot;DESC&quot;</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="kr">const</span> <span class="nx">filter</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">accountId</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$in</span><span class="o">:</span> <span class="nx">network</span> <span class="p">}</span> <span class="p">};</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">queryArgs</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">before</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">sort</span> <span class="p">};</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">edges</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">pagination</span><span class="p">.</span><span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">);</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">pageInfo</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">pagination</span><span class="p">.</span><span class="nx">getPageInfo</span><span class="p">(</span><span class="nx">edges</span><span class="p">,</span> <span class="nx">queryArgs</span><span class="p">);</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="p">{</span> <span class="nx">edges</span><span class="p">,</span> <span class="nx">pageInfo</span> <span class="p">};</span>
</span>  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">ProfilesDataSource</span><span class="p">;</span>
</pre></div>

<p>Instead of only passing in the <code>network</code> array to this method, we now pass in an object containing all of the information that we’ll need to make our paginated query. Next, instead of passing <code>{ accountId: { $in: network } }</code> directly into the model’s <code>find</code> method, we create a sort object based on the <code>ProfileOrderBy</code> Enum that was passed as an argument to the field. We split the Enum value at its underscore characters and pop off the sort direction at the end, then convert the remaining items back into camel case string. We set the direction of the sort field to <code>-1</code> or <code>1</code> based on whether the Enum value indicated descending or ascending direction. And we assume that an <code>orderBy</code> value will always be available because we set the default value for this field argument to be <code>USERNAME_ASC</code>.</p>
<p>After that, we organize our query arguments into one <code>queryArgs</code> object and pass it into the <code>Pagination</code> object’s <code>getEdges</code> method. We then use the resulting <code>edges</code> as an argument to the <code>getPageInfo</code> method with the <code>queryArgs</code>. Finally, we return the <code>edges</code> and the <code>pageInfo</code> objects in the shape that the <code>network</code> field resolver now expects.</p>
<p>Thinking ahead to where else we may use pagination in this service’s schema, it seems like it would be a good idea to abstract away the code that sets the sort field and direction into a separate method. To that end, we’ll create a <code>_getProfileSort</code> method:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/dataSources/ProfilesDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">class</span> <span class="nx">ProfilesDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">_getProfileSort</span><span class="p">(</span><span class="nx">sortEnum</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">sortArgs</span> <span class="o">=</span> <span class="nx">sortEnum</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">);</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">direction</span> <span class="o">=</span> <span class="nx">sortArgs</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">sortArgs</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">arg</span> <span class="p">=&gt;</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">())</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">arg</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">=&gt;</span>
</span><span class="hll">        <span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">arg</span> <span class="o">:</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">()</span> <span class="o">+</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class="hll">      <span class="p">)</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
</span><span class="hll">    <span class="nx">sort</span><span class="p">[</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="nx">direction</span> <span class="o">===</span> <span class="s2">&quot;DESC&quot;</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="nx">sort</span><span class="p">;</span>
</span><span class="hll">  <span class="p">}</span>
</span><span class="hll">
</span>  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">ProfilesDataSource</span><span class="p">;</span>
</pre></div>

<p>Let’s update the <code>getNetworkProfiles</code> method to use the <code>_getProfileSort</code> helper:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/dataSources/ProfilesDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">class</span> <span class="nx">ProfilesDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">getNetworkProfiles</span><span class="p">({</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">before</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">orderBy</span><span class="p">,</span> <span class="nx">network</span> <span class="p">})</span> <span class="p">{</span>
<span class="hll">    <span class="kr">const</span> <span class="nx">sort</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getProfileSort</span><span class="p">(</span><span class="nx">orderBy</span><span class="p">);</span>
</span>    <span class="kr">const</span> <span class="nx">filter</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">accountId</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$in</span><span class="o">:</span> <span class="nx">network</span> <span class="p">}</span> <span class="p">};</span>
    <span class="kr">const</span> <span class="nx">queryArgs</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">before</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">sort</span> <span class="p">};</span>
    <span class="kr">const</span> <span class="nx">edges</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">pagination</span><span class="p">.</span><span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">pageInfo</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">pagination</span><span class="p">.</span><span class="nx">getPageInfo</span><span class="p">(</span><span class="nx">edges</span><span class="p">,</span> <span class="nx">queryArgs</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">{</span> <span class="nx">edges</span><span class="p">,</span> <span class="nx">pageInfo</span> <span class="p">};</span>
  <span class="p">}</span>
  
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">ProfilesDataSource</span><span class="p">;</span>
</pre></div>

<p>We can now update the <code>network</code> field resolver in <code>resolvers.js</code>:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/resolvers.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">resolvers</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">Profile</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">network</span><span class="p">(</span><span class="nx">profile</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="p">{</span> <span class="nx">dataSources</span> <span class="p">})</span> <span class="p">{</span>
<span class="hll">      <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">profilesAPI</span><span class="p">.</span><span class="nx">getNetworkProfiles</span><span class="p">({</span>
</span><span class="hll">        <span class="p">...</span><span class="nx">args</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">network</span><span class="o">:</span> <span class="nx">profile</span><span class="p">.</span><span class="nx">network</span>
</span><span class="hll">      <span class="p">});</span>
</span>    <span class="p">},</span>
    <span class="c1">// ...</span>
  <span class="p">},</span>

  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">resolvers</span><span class="p">;</span>
</pre></div>

<p>In the updated resolver above, instead of only passing the array of network member account IDs to the data source method we must pass in an object containing both this array and the pagination arguments that will be contained in <code>args</code>.</p>
<p>Now we’re ready to test the query:</p>
<p></p>
<div class="code-context">
<p>GraphQL Query</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">query</span> <span class="k">Network</span><span class="p">(</span><span class="nv">$username</span><span class="p">:</span> <span class="k">String</span><span class="p">!</span>, <span class="nv">$first</span><span class="p">:</span> <span class="k">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">profile</span><span class="p">(</span>username: <span class="nv">$username</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">username</span>
    <span class="k">network</span><span class="p">(</span>first: <span class="nv">$first</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">edges</span> <span class="p">{</span>
        <span class="k">cursor</span>
        <span class="k">node</span> <span class="p">{</span>
          <span class="k">username</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">pageInfo</span> <span class="p">{</span>
        <span class="k">endCursor</span>
        <span class="k">hasNextPage</span>
        <span class="k">hasPreviousPage</span>
        <span class="k">startCursor</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>Query Variables</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
  <span class="nt">&quot;first&quot;</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;profile&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
      <span class="nt">&quot;network&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed5a652707218760b0122&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;ada_lovelace&quot;</span>
            <span class="p">}</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed61552707218760b0124&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;alan_turing&quot;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">],</span>
        <span class="nt">&quot;pageInfo&quot;</span><span class="p">:</span> <span class="p">{</span>
          <span class="nt">&quot;endCursor&quot;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
          <span class="nt">&quot;hasNextPage&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="nt">&quot;hasPreviousPage&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="nt">&quot;startCursor&quot;</span><span class="p">:</span> <span class="kc">null</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>As expected, we get back the first two results sorted by username in ascending alphabetical order. We can also see that <code>pageInfo</code> returns the placeholder values. Try adding an <code>orderBy</code> argument now to the query to ensure it works as expected:</p>
<p></p>
<div class="code-context">
<p>GraphQL Query</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">query</span> <span class="k">Network</span><span class="p">(</span><span class="nv">$username</span><span class="p">:</span> <span class="k">String</span><span class="p">!</span>, <span class="nv">$first</span><span class="p">:</span> <span class="k">Int</span>, <span class="nv">$orderBy</span><span class="p">:</span> <span class="k">ProfileOrderBy</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">profile</span><span class="p">(</span>username: <span class="nv">$username</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">username</span>
    <span class="k">network</span><span class="p">(</span>first: <span class="nv">$first</span>, orderBy: <span class="nv">$orderBy</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">edges</span> <span class="p">{</span>
        <span class="k">cursor</span>
        <span class="k">node</span> <span class="p">{</span>
          <span class="k">username</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>Query Variables</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
  <span class="nt">&quot;first&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="nt">&quot;orderBy&quot;</span><span class="p">:</span> <span class="s2">&quot;USERNAME_DESC&quot;</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;profile&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
      <span class="nt">&quot;network&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed6c052707218760b012a&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;margaret_hamilton&quot;</span>
            <span class="p">}</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed69a52707218760b0128&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;grace_hopper&quot;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Now we see the last two profiles on the first page of results because they are sorted in descending alphabetical order. As a final test of forward pagination, try querying for the second page of results using the <code>after</code> argument. We’ll use a specific user’s profile ID (the example below uses Alan Turing’s ID) so we can see what profiles come after him in ascending order:</p>
<p></p>
<div class="code-context">
<p>GraphQL Query</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">query</span> <span class="k">Network</span><span class="p">(</span><span class="nv">$username</span><span class="p">:</span> <span class="k">String</span><span class="p">!</span>, <span class="nv">$first</span><span class="p">:</span> <span class="k">Int</span>, <span class="nv">$after</span><span class="p">:</span> <span class="k">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">profile</span><span class="p">(</span>username: <span class="nv">$username</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">username</span>
    <span class="k">network</span><span class="p">(</span>first: <span class="nv">$first</span>, after: <span class="nv">$after</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">edges</span> <span class="p">{</span>
        <span class="k">cursor</span>
        <span class="k">node</span> <span class="p">{</span>
          <span class="k">username</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>Query Variables</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
  <span class="nt">&quot;first&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="nt">&quot;after&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed61552707218760b0124&quot;</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;profile&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
      <span class="nt">&quot;network&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed64852707218760b0126&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;george_boole&quot;</span>
            <span class="p">}</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed69a52707218760b0128&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;grace_hopper&quot;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="add-backward-pagination-to-the-network-field">Add Backward Pagination to the <code>network</code> Field</h2>
<p>Forward pagination is functional, so we’ll finish building out backward pagination now. We first need to complete the <code>_reverseSortDirection</code> method in <code>Pagination.js</code>. This method will flip the sort direction when using backward pagination so that we can work from the end of the results and provide what would ordinarily be the end page at the beginning. To do this, we must set the sort object’s key to be <code>-1</code> if it’s initially <code>1</code> and <code>1</code> if it’s initially <code>-1</code>:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">_reverseSortDirection</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">fieldArr</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="nx">fieldArr</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="p">{</span> <span class="nx">$natural</span><span class="o">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">    <span class="kr">const</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">fieldArr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="hll">    <span class="k">return</span> <span class="p">{</span> <span class="p">[</span><span class="nx">field</span><span class="p">]</span><span class="o">:</span> <span class="nx">sort</span><span class="p">[</span><span class="nx">field</span><span class="p">]</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
</span><span class="hll">  <span class="p">}</span>
</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>Inside this method, we check if the sort object was empty (indicated by the array resulting from <code>Object.keys</code> having a length of <code>0</code>). If nothing was provided as a sort field, then we flip the <code>$natural</code> sort order, which is the default sort order that MongoDB refers to the documents on disk. We return a new object with the reserved sort order from this method because we don’t want to mutate the original <code>sort</code> object (doing so would create bugs elsewhere in the pagination code).</p>
<p>Now we’ll put <code>_reverseSortDirection</code> to use in the <code>getEdges</code> method so it supports backward pagination when a <code>last</code> argument is provided:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span> else <span class="p">{</span>
<span class="hll">      <span class="kr">const</span> <span class="nx">reverseSort</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_reverseSortDirection</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">      <span class="kr">const</span> <span class="nx">operator</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getOperator</span><span class="p">(</span><span class="nx">reverseSort</span><span class="p">);</span>
</span><span class="hll">
</span><span class="hll">      <span class="kr">const</span> <span class="nx">queryDoc</span> <span class="o">=</span> <span class="nx">before</span>
</span><span class="hll">        <span class="o">?</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getFilterWithCursor</span><span class="p">(</span><span class="nx">before</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">operator</span><span class="p">,</span> <span class="nx">reverseSort</span><span class="p">)</span>
</span><span class="hll">        <span class="o">:</span> <span class="nx">filter</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">      <span class="kr">const</span> <span class="nx">docs</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">queryDoc</span><span class="p">)</span>
</span><span class="hll">        <span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">reverseSort</span><span class="p">)</span>
</span><span class="hll">        <span class="p">.</span><span class="nx">limit</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span>
</span><span class="hll">        <span class="p">.</span><span class="nx">exec</span><span class="p">();</span>
</span><span class="hll">
</span><span class="hll">      <span class="nx">edges</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">length</span>
</span><span class="hll">        <span class="o">?</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">doc</span> <span class="p">=&gt;</span> <span class="p">({</span> <span class="nx">node</span><span class="o">:</span> <span class="nx">doc</span><span class="p">,</span> <span class="nx">cursor</span><span class="o">:</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">_id</span> <span class="p">})).</span><span class="nx">reverse</span><span class="p">()</span>
</span><span class="hll">        <span class="o">:</span> <span class="p">[];</span>
</span>    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>This code is very similar to forward pagination, but with three notable differences. First, we call the <code>_reverseSortDirection</code> method, passing in the <code>sort</code> object from the <code>queryArgs</code>, and set the <code>reverseSort</code> variable based on the return value. We reverse the sort order internally (for example, <code>{ username: 1 }</code> becomes <code>{ username: -1 }</code>) because with backward pagination, even if we want the individual page of the results to be in ascending order, we still need MongoDB to start its query from the end of the results and then move toward the front from there. The reverse would be true for backward pagination in descending order.</p>
<p>The second difference is that the ternary expression that sets the <code>queryDoc</code> value checks <code>before</code> instead of <code>after</code>. Finally, we chain the <code>reverse</code> array method onto the output of <code>map</code> because even though we have to start counting documents from the end (this is why we flipped the sort direction at the beginning), we still want the individual results on each page to be in the correct ascending or descending order, so <code>reverse</code> puts them back in the expected order.</p>
<p>Now we can restart the profiles service to pick up the changes made to the <code>Pagination</code> class and test out backward pagination:</p>
<p></p>
<div class="code-context">
<p>GraphQL Query</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">query</span> <span class="k">Network</span><span class="p">(</span><span class="nv">$username</span><span class="p">:</span> <span class="k">String</span><span class="p">!</span>, <span class="nv">$last</span><span class="p">:</span> <span class="k">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">profile</span><span class="p">(</span>username: <span class="nv">$username</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">username</span>
    <span class="k">network</span><span class="p">(</span>last: <span class="nv">$last</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">edges</span> <span class="p">{</span>
        <span class="k">cursor</span>
        <span class="k">node</span> <span class="p">{</span>
          <span class="k">username</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>Query Variables</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
  <span class="nt">&quot;last&quot;</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;profile&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
      <span class="nt">&quot;network&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed69a52707218760b0128&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;grace_hopper&quot;</span>
            <span class="p">}</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed6c052707218760b012a&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;margaret_hamilton&quot;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>We can get the next (but really previous!) page of results using Grace Hopper’s document ID:</p>
<p></p>
<div class="code-context">
<p>GraphQL Query</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">query</span> <span class="k">Network</span><span class="p">(</span><span class="nv">$username</span><span class="p">:</span> <span class="k">String</span><span class="p">!</span>, <span class="nv">$last</span><span class="p">:</span> <span class="k">Int</span>, <span class="nv">$before</span><span class="p">:</span> <span class="k">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">profile</span><span class="p">(</span>username: <span class="nv">$username</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">username</span>
    <span class="k">network</span><span class="p">(</span>last: <span class="nv">$last</span>, before: <span class="nv">$before</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">edges</span> <span class="p">{</span>
        <span class="k">cursor</span>
        <span class="k">node</span> <span class="p">{</span>
          <span class="k">username</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>Query Variables</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
  <span class="nt">&quot;last&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="nt">&quot;before&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed69a52707218760b0128&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;profile&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
      <span class="nt">&quot;network&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed61552707218760b0124&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;alan_turing&quot;</span>
            <span class="p">}</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed64852707218760b0126&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;george_boole&quot;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Now try out descending order with backward pagination:</p>
<p></p>
<div class="code-context">
<p>GraphQL Query</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">query</span> <span class="k">Network</span><span class="p">(</span><span class="nv">$username</span><span class="p">:</span> <span class="k">String</span><span class="p">!</span>, <span class="nv">$last</span><span class="p">:</span> <span class="k">Int</span>, <span class="nv">$orderBy</span><span class="p">:</span> <span class="k">ProfileOrderBy</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">profile</span><span class="p">(</span>username: <span class="nv">$username</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">username</span>
    <span class="k">network</span><span class="p">(</span>last: <span class="nv">$last</span>, orderBy: <span class="nv">$orderBy</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">edges</span> <span class="p">{</span>
        <span class="k">cursor</span>
        <span class="k">node</span> <span class="p">{</span>
          <span class="k">username</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>Query Variables</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
  <span class="nt">&quot;last&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="nt">&quot;orderBy&quot;</span><span class="p">:</span> <span class="s2">&quot;USERNAME_DESC&quot;</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;profile&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
      <span class="nt">&quot;network&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed61552707218760b0124&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;alan_turing&quot;</span>
            <span class="p">}</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed5a652707218760b0122&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;ada_lovelace&quot;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="generate-the-pageinfo-to-include-in-the-response">Generate the <code>PageInfo</code> to Include in the Response</h2>
<p>With forward and backward pagination functional, we can put the final pieces of the pagination puzzle in place by resolving real data for <code>PageInfo</code>. Our first step will be to write the <code>_getStartCursor</code> and <code>_getEndCursor</code> methods. Respectively, these methods only need to return the first and last cursor IDs from a list of queried edges:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">_getStartCursor</span><span class="p">(</span><span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">edges</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="nx">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">cursor</span><span class="p">;</span>
</span><span class="hll">  <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">  <span class="nx">_getEndCursor</span><span class="p">(</span><span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">edges</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="nx">edges</span><span class="p">[</span><span class="nx">edges</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nx">cursor</span><span class="p">;</span>
</span><span class="hll">  <span class="p">}</span>
</span><span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>Now we’ll work on the <code>_getHasNextPage</code> method. This method’s job is to determine if there’s at least one document beyond the current page, and then return <code>true</code> if a document exists or <code>false</code> if one doesn’t. The Relay specification indicates that we don’t necessarily need to provide a value for <code>hasNextPage</code> when paginating backward—this is only recommended when it is efficient to do so. Otherwise, we could just return <code>false</code> in the backward pagination scenario. It’s reasonably efficient for us to calculate this so we will be able to supply a real value here. The same will be true for forward pagination when checking for a previous page later on:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">async</span> <span class="nx">_getHasNextPage</span><span class="p">(</span><span class="nx">endCursor</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">operator</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getOperator</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">queryDoc</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getFilterWithCursor</span><span class="p">(</span>
</span><span class="hll">      <span class="nx">endCursor</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">filter</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">operator</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">sort</span>
</span><span class="hll">    <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">    <span class="kr">const</span> <span class="nx">nextPage</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">findOne</span><span class="p">(</span><span class="nx">queryDoc</span><span class="p">)</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="nb">Boolean</span><span class="p">(</span><span class="nx">nextPage</span><span class="p">);</span>
</span><span class="hll">  <span class="p">}</span>
</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>In this method, we create a <code>queryDoc</code> variable like before, but this time we use the <code>endCursor</code> value as the <code>fromCursorId</code> argument because we want to know if anything exists beyond the end cursor. Next, we pass the <code>queryDoc</code> into <code>findOne</code> and then chain on <code>select</code> to only retrieve the <code>_id</code> field for the document because we don’t care about the content of the document—we just want to know that it exists and then apply the sort. Lastly, we coerce the returned document or <code>null</code> into a boolean so we can return <code>true</code> or <code>false</code> from this method.</p>
<p>Now we’ll create the <code>_getHasPreviousPage</code> method in a similar fashion:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">async</span> <span class="nx">_getHasPreviousPage</span><span class="p">(</span><span class="nx">startCursor</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">reverseSort</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_reverseSortDirection</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">operator</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getOperator</span><span class="p">(</span><span class="nx">reverseSort</span><span class="p">);</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">queryDoc</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getFilterWithCursor</span><span class="p">(</span>
</span><span class="hll">      <span class="nx">startCursor</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">filter</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">operator</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">reverseSort</span>
</span><span class="hll">    <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">    <span class="kr">const</span> <span class="nx">prevPage</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">findOne</span><span class="p">(</span><span class="nx">queryDoc</span><span class="p">)</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
</span><span class="hll">      <span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">reverseSort</span><span class="p">);</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="nb">Boolean</span><span class="p">(</span><span class="nx">prevPage</span><span class="p">);</span>
</span><span class="hll">  <span class="p">}</span>
</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>As we did with backward pagination, we must again reverse the sort direction. To determine whether there’s a previous page we need to flip the comparison operator and then check if at least one result comes before the <code>startCursor</code> for ascending pagination, or at least one result comes after it for descending pagination.</p>
<p>Finally, we can update <code>getPageInfo</code> using all of the new methods to calculate real values if there are any items in the <code>edges</code> array:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">getPageInfo</span><span class="p">(</span><span class="nx">edges</span><span class="p">,</span> <span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="nx">edges</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="kr">const</span> <span class="p">{</span> <span class="nx">filter</span> <span class="o">=</span> <span class="p">{}</span>, sort = <span class="p">{}</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">queryArgs</span><span class="p">;</span>
</span><span class="hll">      <span class="kr">const</span> <span class="nx">startCursor</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getStartCursor</span><span class="p">(</span><span class="nx">edges</span><span class="p">);</span>
</span><span class="hll">      <span class="kr">const</span> <span class="nx">endCursor</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getEndCursor</span><span class="p">(</span><span class="nx">edges</span><span class="p">);</span>
</span><span class="hll">      <span class="kr">const</span> <span class="nx">hasNextPage</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getHasNextPage</span><span class="p">(</span>
</span><span class="hll">        <span class="nx">endCursor</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">filter</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">sort</span>
</span><span class="hll">      <span class="p">);</span>
</span><span class="hll">      <span class="kr">const</span> <span class="nx">hasPreviousPage</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getHasPreviousPage</span><span class="p">(</span>
</span><span class="hll">        <span class="nx">startCursor</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">filter</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">sort</span>
</span><span class="hll">      <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">      <span class="k">return</span> <span class="p">{</span>
</span><span class="hll">        <span class="nx">hasNextPage</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">hasPreviousPage</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">startCursor</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">endCursor</span>
</span><span class="hll">      <span class="p">};</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">
</span>    return <span class="p">{</span>
      <span class="nx">hasNextPage</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="nx">hasPreviousPage</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="nx">startCursor</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
      <span class="nx">endCursor</span><span class="o">:</span> <span class="kc">null</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>If we perform any queries now, we should be able to see accurate <code>pageInfo</code>. Try querying the second page of results and confirm that <code>hasPreviousPage</code> and <code>hasNextPage</code> are both <code>true</code>:</p>
<p></p>
<div class="code-context">
<p>GraphQL Query</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">query</span> <span class="k">Network</span><span class="p">(</span><span class="nv">$username</span><span class="p">:</span> <span class="k">String</span><span class="p">!</span>, <span class="nv">$first</span><span class="p">:</span> <span class="k">Int</span>, <span class="nv">$after</span><span class="p">:</span> <span class="k">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">profile</span><span class="p">(</span>username: <span class="nv">$username</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">username</span>
    <span class="k">network</span><span class="p">(</span>first: <span class="nv">$first</span>, after: <span class="nv">$after</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">edges</span> <span class="p">{</span>
        <span class="k">cursor</span>
        <span class="k">node</span> <span class="p">{</span>
          <span class="k">username</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">pageInfo</span> <span class="p">{</span>
        <span class="k">hasPreviousPage</span>
        <span class="k">hasNextPage</span>
        <span class="k">startCursor</span>
        <span class="k">endCursor</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>Query Variables</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
  <span class="nt">&quot;first&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="nt">&quot;after&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed61552707218760b0124&quot;</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;profile&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;marksalot&quot;</span><span class="p">,</span>
      <span class="nt">&quot;network&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed64852707218760b0126&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;george_boole&quot;</span>
            <span class="p">}</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&quot;cursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed69a52707218760b0128&quot;</span><span class="p">,</span>
            <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;grace_hopper&quot;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">],</span>
        <span class="nt">&quot;pageInfo&quot;</span><span class="p">:</span> <span class="p">{</span>
          <span class="nt">&quot;hasPreviousPage&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nt">&quot;hasNextPage&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nt">&quot;startCursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed64852707218760b0126&quot;</span><span class="p">,</span>
          <span class="nt">&quot;endCursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed69a52707218760b0128&quot;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="add-pagination-to-profiles-and-searchprofiles-fields">Add Pagination to <code>profiles</code> and <code>searchProfiles</code> Fields</h2>
<p>With pagination up and running for the <code>network</code> field on the <code>Profile</code> type, we’ll finish up this chapter by adding pagination for the <code>profiles</code> and <code>searchProfiles</code> queries. Adding pagination to the <code>profiles</code> field will be easier than <code>searchProfiles</code>, so we’ll start there.</p>
<p>First, we’ll update the <code>profiles</code> field in the profiles service’s schema to accept pagination-related arguments. We also need to update it to return a single <code>ProfileConnection</code> now instead:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/schema.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Singline"># ...</span>

<span class="kt">type</span> <span class="k">Query</span> <span class="p">{</span>
  <span class="c c-Singline"># ...</span>
  <span class="s2">&quot;Retrieves a list of profiles.&quot;</span>
<span class="hll">  <span class="k">profiles</span><span class="p">(</span>
</span><span class="hll">    after: <span class="k">String</span>
</span><span class="hll">    before: <span class="k">String</span>
</span><span class="hll">    first: <span class="k">Int</span>
</span><span class="hll">    last: <span class="k">Int</span>
</span><span class="hll">    orderBy: <span class="k">ProfileOrderBy</span> <span class="p">=</span> <span class="k">USERNAME_ASC</span>
</span><span class="hll">  <span class="p">):</span> <span class="k">ProfileConnection</span> <span class="kt">@private</span>
</span>  <span class="c c-Singline"># ...</span>
<span class="p">}</span>

<span class="c c-Singline"># ...</span>
</pre></div>

<p>Next, we’ll update the <code>getProfiles</code> method in the <code>ProfilesDataSource</code> class:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/dataSources/ProfilesDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">class</span> <span class="nx">ProfilesDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">async</span> <span class="nx">getProfiles</span><span class="p">({</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">before</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">orderBy</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">sort</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getProfileSort</span><span class="p">(</span><span class="nx">orderBy</span><span class="p">);</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">queryArgs</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">before</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">sort</span> <span class="p">};</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">edges</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">pagination</span><span class="p">.</span><span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">);</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">pageInfo</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">pagination</span><span class="p">.</span><span class="nx">getPageInfo</span><span class="p">(</span><span class="nx">edges</span><span class="p">,</span> <span class="nx">queryArgs</span><span class="p">);</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="p">{</span> <span class="nx">edges</span><span class="p">,</span> <span class="nx">pageInfo</span> <span class="p">};</span>
</span>  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">ProfilesDataSource</span><span class="p">;</span>
</pre></div>

<p>The <code>getProfiles</code> method must be <code>async</code> now because we <code>await</code> the promises to get both the <code>edges</code> and <code>pageInfo</code> before returning an object of the combined data from this function. We must also update the <code>getProfiles</code> resolver in <code>resolvers.js</code> so that it passes the pagination <code>args</code> through:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/resolvers.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">resolvers</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">Query</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">profiles</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="p">{</span> <span class="nx">dataSources</span> <span class="p">})</span> <span class="p">{</span>
<span class="hll">      <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">profilesAPI</span><span class="p">.</span><span class="nx">getProfiles</span><span class="p">(</span><span class="nx">args</span><span class="p">);</span>
</span>    <span class="p">},</span>
    <span class="c1">// ...</span>
  <span class="p">},</span>

  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">resolvers</span><span class="p">;</span>
</pre></div>

<p>The paginated <code>profiles</code> query is ready for testing:</p>
<p></p>
<div class="code-context">
<p>GraphQL Query</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">query</span> <span class="k">Profiles</span><span class="p">(</span><span class="nv">$first</span><span class="p">:</span> <span class="k">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">profiles</span><span class="p">(</span>first: <span class="nv">$first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">edges</span> <span class="p">{</span>
      <span class="k">node</span> <span class="p">{</span>
        <span class="k">username</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pageInfo</span> <span class="p">{</span>
      <span class="k">hasPreviousPage</span>
      <span class="k">hasNextPage</span>
      <span class="k">startCursor</span>
      <span class="k">endCursor</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>Query Variables</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;first&quot;</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;profiles&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;ada_lovelace&quot;</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;alan_turing&quot;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">],</span>
      <span class="nt">&quot;pageInfo&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;hasPreviousPage&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="nt">&quot;hasNextPage&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&quot;startCursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed5a652707218760b0122&quot;</span><span class="p">,</span>
        <span class="nt">&quot;endCursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed61552707218760b0124&quot;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Adding pagination to the <code>searchProfiles</code> query will take a bit effort to implement. The first step will be to update the <code>searchProfiles</code> query definition:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/schema.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Singline"># ...</span>

<span class="kt">type</span> <span class="k">Query</span> <span class="p">{</span>
  <span class="c c-Singline"># ...</span>
  <span class="s2">&quot;Performs a search of user profiles. Results are available in descending order by relevance only.&quot;</span>
<span class="hll">  <span class="k">searchProfiles</span><span class="p">(</span>
</span><span class="hll">    after: <span class="k">String</span>
</span><span class="hll">    first: <span class="k">Int</span>
</span><span class="hll">    <span class="s2">&quot;The text string to search for in usernames or full names.&quot;</span>
</span><span class="hll">    query: <span class="k">String</span><span class="p">!</span>
</span><span class="hll">  <span class="p">):</span> <span class="k">ProfileConnection</span> <span class="kt">@private</span>
</span><span class="p">}</span>

<span class="c c-Singline"># ...</span>
</pre></div>

<p>Unlike the <code>network</code> and the <code>profiles</code> fields, we left out the <code>before</code> and <code>last</code> arguments that enable backward pagination. That means we’re deviating from the Relay pagination specification slightly, but there are two good reasons for doing so. The first reason is that the matching documents are sorted in descending order by their relevance when using MongoDB’s full-text search. For most search use cases, it’s hard to imagine a scenario where a user would want to search for and retrieve some items from a database only to see the least relevant items first.</p>
<p>The second reason has to do with how we get MongoDB to sort the documents in order of their relevance. We use the <code>{ $meta: "textScore" }</code> expression to sort the most relevant documents first (rather than using a <code>1</code> or <code>-1</code> to indicate the sort direction on a specific field as we have previously). However, in doing so we allow the <code>$meta</code> expression to assume full control over the sort order, which is descending only. There is no simple way to flip the sort order of these documents as we have done with other paginated queries.</p>
<p>Ultimately, hacking around this MongoDB default doesn’t make much sense because, again, it’s very hard to imagine a scenario where a user would want to see the least relevant search results first. Additionally, and for the same reasons, the <code>searchProfiles</code> query omits what becomes a redundant <code>orderBy</code> argument.</p>
<p>We also can’t rely on the basic <code>find</code> method to implement paginated search results. We will need to use a more advanced feature of MongoDB called <em>aggregation</em>. As defined by the MongoDB documentation:</p>
<blockquote>
<p>Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result.</p>
</blockquote>
<p>A key point to take away from this definition is that aggregations are quite powerful and can be used to group documents and perform operations on them to derive data and insights from the database that go beyond what’s explicitly contained in the documents themselves. Aggregation works by creating a <em>pipeline</em> that documents enter and are subsequently transformed in various stages until a final result is output at the end. If we were to replicate a basic query for members of a user’s network as an aggregation, then it might look something like this:</p>
<div class="highlight"><pre><span></span><span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">([</span>
  <span class="p">{</span> <span class="nx">$match</span><span class="o">:</span> <span class="p">{</span> <span class="nx">_id</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$in</span><span class="o">:</span> <span class="p">[</span> <span class="s2">&quot;_id_1&quot;</span><span class="p">,</span> <span class="s2">&quot;_id_2&quot;</span><span class="p">,</span> <span class="p">...</span> <span class="p">]</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span>,
  <span class="p">{</span> <span class="nx">$sort</span><span class="o">:</span> <span class="p">{</span> <span class="nx">username</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">}</span>,
  <span class="p">{</span> <span class="nx">$limit</span><span class="o">:</span> <span class="mi">20</span> <span class="p">}</span>
<span class="p">]);</span>
</pre></div>

<p>We pass the pipeline as an array argument to the <code>aggregate</code> method to describe the ordered sequence of data aggregation stages to apply to documents in the database. The <code>$match</code> stage is like creating a query document for a regular MongoDB query operation—it will pass only the documents that match the specified filter to the next pipeline stage. The <code>$match</code> stage is then followed by a <code>$sort</code> and a <code>$limit</code> stage before returning the matching documents.</p>
<p>Typically, we wouldn’t use aggregation for a basic query like this, but it will be useful here where we deal with the tricky business of paginating a full-text search query in MongoDB. To set up the basic pipeline, we’ll build out another method in <code>Pagination.js</code> called <code>_getSearchPipeline</code>:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">async</span> <span class="nx">_getSearchPipeline</span><span class="p">(</span><span class="nx">fromCursorId</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">operator</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">textSearchPipeline</span> <span class="o">=</span> <span class="p">[</span>
</span><span class="hll">      <span class="p">{</span> <span class="nx">$match</span><span class="o">:</span> <span class="nx">filter</span> <span class="p">}</span>,
</span><span class="hll">      <span class="p">{</span> <span class="nx">$addFields</span><span class="o">:</span> <span class="p">{</span> <span class="nx">score</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$meta</span><span class="o">:</span> <span class="s2">&quot;textScore&quot;</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span>,
</span><span class="hll">      <span class="p">{</span> <span class="nx">$sort</span><span class="o">:</span> <span class="nx">sort</span> <span class="p">}</span>
</span><span class="hll">    <span class="p">];</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="nx">fromCursorId</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="c1">// add a `$match` stage to get results after a specific cursor...</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">    <span class="nx">textSearchPipeline</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">$limit</span><span class="o">:</span> <span class="nx">first</span> <span class="p">});</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="nx">textSearchPipeline</span><span class="p">;</span>
</span><span class="hll">  <span class="p">}</span>
</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>This method returns an array of the pipeline stages that we’ll later use to pass into the <code>aggregate</code> method. We first match the documents based on the <code>filter</code> with a shape of <code>{ $text: { $search: "some search string" } }</code>. Next, we use <code>$addFields</code> to indicate that we want to keep all existing fields from the input documents and also add the <code>score</code> field to each document. You can think of <code>$addFields</code> as an all-inclusive projection that also provides an opportunity to add more fields to the documents at this stage. We then sort the documents by relevance, and we also add a <code>$limit</code> stage at the very end of the pipeline, just before it’s returned from the method.</p>
<p>If the <code>fromCursorId</code> argument is defined, then we will first find the <code>fromDoc</code> as we did in <code>_getFilterWithCursor</code>, but this time also add the text search to the query document and specify a projection document that includes the score.</p>
<p>If there are no errors while retrieving the document, then we add another <code>$match</code> stage to the pipeline that will return documents where the score is either greater than or less than the <code>fromDoc</code> score, or where the score is equal but the ID is greater than or less than the <code>_id</code> of the <code>fromDoc</code>. When looking ahead to the next page of results, the <code>operator</code> will be <code>$lt</code> because the documents are sorted in descending order by score and <code>_id</code>. Conversely, when looking back for a previous page of results, the operator will be <code>$gt</code>:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">_getSearchPipeline</span><span class="p">(</span><span class="nx">fromCursorId</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">operator</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">fromCursorId</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">      <span class="kr">const</span> <span class="nx">fromDoc</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">findOne</span><span class="p">({</span>
</span><span class="hll">        <span class="p">...</span><span class="nx">filter</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">_id</span><span class="o">:</span> <span class="nx">fromCursorId</span>
</span><span class="hll">      <span class="p">})</span>
</span><span class="hll">        <span class="p">.</span><span class="nx">select</span><span class="p">({</span> <span class="nx">score</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$meta</span><span class="o">:</span> <span class="s2">&quot;textScore&quot;</span> <span class="p">}</span> <span class="p">})</span>
</span><span class="hll">        <span class="p">.</span><span class="nx">exec</span><span class="p">();</span>
</span><span class="hll">
</span><span class="hll">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fromDoc</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">        <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span><span class="sb">`No record found for ID &#39;</span><span class="si">${</span><span class="nx">fromCursorId</span><span class="si">}</span><span class="sb">&#39;`</span><span class="p">);</span>
</span><span class="hll">      <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">      <span class="nx">textSearchPipeline</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
</span><span class="hll">        <span class="nx">$match</span><span class="o">:</span> <span class="p">{</span>
</span><span class="hll">          <span class="nx">$or</span><span class="o">:</span> <span class="p">[</span>
</span><span class="hll">            <span class="p">{</span> <span class="nx">score</span><span class="o">:</span> <span class="p">{</span> <span class="p">[</span><span class="nx">operator</span><span class="p">]</span><span class="o">:</span> <span class="nx">fromDoc</span><span class="p">.</span><span class="nx">_doc</span><span class="p">.</span><span class="nx">score</span> <span class="p">}</span> <span class="p">}</span>,
</span><span class="hll">            <span class="p">{</span>
</span><span class="hll">              <span class="nx">score</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$eq</span><span class="o">:</span> <span class="nx">fromDoc</span><span class="p">.</span><span class="nx">_doc</span><span class="p">.</span><span class="nx">score</span> <span class="p">}</span>,
</span><span class="hll">              _id: <span class="p">{</span> <span class="p">[</span><span class="nx">operator</span><span class="p">]</span><span class="o">:</span> <span class="nx">fromCursorId</span> <span class="p">}</span>
</span><span class="hll">            <span class="p">}</span>
</span><span class="hll">          <span class="p">]</span>
</span><span class="hll">        <span class="p">}</span>
</span><span class="hll">      <span class="p">});</span>
</span>    <span class="p">}</span>

    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>Before we can update the <code>ProfilesDataSource</code> we need to do some refactoring of the <code>Pagination</code> class to check if a particular query is a search operation. If it is, then we’ll use the aggregation we just set up instead of a regular <code>find</code> query. To do that, we’ll finish writing the <code>_isSearchQuery</code> method, which is the last method we need to create in this class. This method is a simple helper that looks at the sort expression to determine if the documents are sorted on <code>score</code> (because documents are only sorted on <code>score</code> for search queries):</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">_isSearchQuery</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">fieldArr</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">    <span class="k">return</span> <span class="nx">fieldArr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldArr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&quot;score&quot;</span><span class="p">;</span>
</span><span class="hll">  <span class="p">}</span>
</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>Now we can update the <code>_getOperator</code> method to check if the sorting uses a <code>{ score: { $meta: "textScore" } }</code> expression instead of integer sort value. We will use the <code>options</code> parameter to pass in an optional flag to let the method know that we’re dealing with a search query sorted by <code>textScore</code>.</p>
<p>If we are handling a search query, then we want to check if any documents exist with a <code>score</code> and <code>_id</code> greater than those of the <code>startCursor</code> on the current page of results for a <code>_getHasPreviousPage</code> check. Otherwise, we’ll look for documents with <code>score</code> and <code>_id</code> less than the <code>endCursor</code> of the current page:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">_getOperator</span><span class="p">(</span><span class="nx">sort</span><span class="p">,</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">orderArr</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
<span class="hll">    <span class="kr">const</span> <span class="nx">checkPreviousTextScore</span> <span class="o">=</span> <span class="nx">options</span><span class="o">?</span><span class="p">.</span><span class="nx">checkPreviousTextScore</span>
</span><span class="hll">      <span class="o">?</span> <span class="nx">options</span><span class="p">.</span><span class="nx">checkPreviousTextScore</span>
</span><span class="hll">      <span class="o">:</span> <span class="kc">false</span><span class="p">;</span>
</span><span class="hll">    <span class="kd">let</span> <span class="nx">operator</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_isSearchQuery</span><span class="p">(</span><span class="nx">sort</span><span class="p">))</span> <span class="p">{</span>
</span><span class="hll">      <span class="nx">operator</span> <span class="o">=</span> <span class="nx">checkPreviousTextScore</span> <span class="o">?</span> <span class="s2">&quot;$gt&quot;</span> <span class="o">:</span> <span class="s2">&quot;$lt&quot;</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span> else <span class="p">{</span>
</span><span class="hll">      <span class="nx">operator</span> <span class="o">=</span> <span class="nx">orderArr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">orderArr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="s2">&quot;$lt&quot;</span> <span class="o">:</span> <span class="s2">&quot;$gt&quot;</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="nx">operator</span><span class="p">;</span>
</span>  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>Now we need to update the <code>getEdges</code>, <code>_getHasNextPage</code>, and <code>_getHasPreviousPage</code> methods to use <code>_getOperator</code>. In <code>getEdges</code>, we will first add a check to see if we’re dealing with a search query using <code>_isSearchQuery</code>, and then add an additional error check to prevent backward pagination on a search query:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="p">{</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">before</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">filter</span> <span class="o">=</span> <span class="p">{}</span>, sort = <span class="p">{}</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">queryArgs</span><span class="p">;</span>
<span class="hll">    <span class="kr">const</span> <span class="nx">isSearch</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_isSearchQuery</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span>    <span class="kd">let</span> <span class="nx">edges</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">first</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">last</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span>
        <span class="s2">&quot;Provide a `first` or `last` value to paginate this connection.&quot;</span>
      <span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">&amp;&amp;</span> <span class="nx">last</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span>
        <span class="s2">&quot;Passing `first` and `last` arguments is not supported with this connection.&quot;</span>
      <span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">last</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span>
        <span class="s2">&quot;Minimum record request for `first` and `last` arguments is 0.&quot;</span>
      <span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">||</span> <span class="nx">last</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span>
        <span class="s2">&quot;Maximum record request for `first` and `last` arguments is 100.&quot;</span>
      <span class="p">);</span>
<span class="hll">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">first</span> <span class="o">&amp;&amp;</span> <span class="nx">isSearch</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span><span class="s2">&quot;Search queries may only be paginated forward.&quot;</span><span class="p">);</span>
</span><span class="hll">    <span class="p">}</span>
</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>We can now update the <code>if</code> / <code>else</code> block to include a check for a <code>true</code> value of <code>isSearch</code>. We’ll add this at the very top by changing <code>if (first)</code> to <code>else if (first)</code>, get the operator as usual, get the aggregation pipeline, call the <code>aggregate</code> method on the model, and then map over the returned documents to set <code>edges</code> to the correct shape:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>

<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="nx">isSearch</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="kr">const</span> <span class="nx">operator</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getOperator</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">      <span class="kr">const</span> <span class="nx">pipeline</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getSearchPipeline</span><span class="p">(</span>
</span><span class="hll">        <span class="nx">after</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">filter</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">first</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">operator</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">sort</span>
</span><span class="hll">      <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">      <span class="kr">const</span> <span class="nx">docs</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">(</span><span class="nx">pipeline</span><span class="p">);</span>
</span><span class="hll">
</span><span class="hll">      <span class="nx">edges</span> <span class="o">=</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">length</span>
</span><span class="hll">        <span class="o">?</span> <span class="nx">docs</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">doc</span> <span class="p">=&gt;</span> <span class="p">({</span> <span class="nx">node</span><span class="o">:</span> <span class="nx">doc</span><span class="p">,</span> <span class="nx">cursor</span><span class="o">:</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">_id</span> <span class="p">}))</span>
</span><span class="hll">        <span class="o">:</span> <span class="p">[];</span>
</span><span class="hll">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">{</span>
</span>      <span class="c1">// ...</span>
    <span class="p">}</span> else <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">edges</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>If <code>after</code> is <code>undefined</code>, then we won’t have any issues because the <code>_getSearchPipeline</code> method checks for this before attempting to find a <code>fromDoc</code>. Next, we can update the <code>_getHasNextPage</code> method to use the aggregation for search queries:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">_getHasNextPage</span><span class="p">(</span><span class="nx">endCursor</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="kr">const</span> <span class="nx">isSearch</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_isSearchQuery</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span>    <span class="kr">const</span> <span class="nx">operator</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getOperator</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
<span class="hll">    <span class="kd">let</span> <span class="nx">nextPage</span><span class="p">;</span>
</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="nx">isSearch</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="kr">const</span> <span class="nx">pipeline</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getSearchPipeline</span><span class="p">(</span>
</span><span class="hll">        <span class="nx">endCursor</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">filter</span><span class="p">,</span>
</span><span class="hll">        <span class="mi">1</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">operator</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">sort</span>
</span><span class="hll">      <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">      <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">(</span><span class="nx">pipeline</span><span class="p">);</span>
</span><span class="hll">      <span class="nx">nextPage</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span> else <span class="p">{</span>
</span>      <span class="kr">const</span> <span class="nx">queryDoc</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getFilterWithCursor</span><span class="p">(</span>
        <span class="nx">endCursor</span><span class="p">,</span>
        <span class="nx">filter</span><span class="p">,</span>
        <span class="nx">operator</span><span class="p">,</span>
        <span class="nx">sort</span>
      <span class="p">);</span>

<span class="hll">      <span class="nx">nextPage</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">findOne</span><span class="p">(</span><span class="nx">queryDoc</span><span class="p">)</span>
</span>        <span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
<span class="hll">    <span class="p">}</span>
</span>
    <span class="k">return</span> <span class="nb">Boolean</span><span class="p">(</span><span class="nx">nextPage</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>And similarly update the <code>_getHasPreviousPage</code> method:</p>
<p></p>
<div class="code-context">
<p>shared/src/utils/Pagination.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Pagination</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">async</span> <span class="nx">_getHasPreviousPage</span><span class="p">(</span><span class="nx">startCursor</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">    <span class="kr">const</span> <span class="nx">isSearch</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_isSearchQuery</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
</span><span class="hll">    <span class="kd">let</span> <span class="nx">prevPage</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="nx">isSearch</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="kr">const</span> <span class="nx">operator</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getOperator</span><span class="p">(</span><span class="nx">sort</span><span class="p">,</span> <span class="p">{</span>
</span><span class="hll">        <span class="nx">checkPreviousTextScore</span><span class="o">:</span> <span class="kc">true</span>
</span><span class="hll">      <span class="p">});</span>
</span><span class="hll">
</span><span class="hll">      <span class="kr">const</span> <span class="nx">pipeline</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getSearchPipeline</span><span class="p">(</span>
</span><span class="hll">        <span class="nx">startCursor</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">filter</span><span class="p">,</span>
</span><span class="hll">        <span class="mi">1</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">operator</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">sort</span>
</span><span class="hll">      <span class="p">);</span>
</span><span class="hll">
</span><span class="hll">      <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">(</span><span class="nx">pipeline</span><span class="p">);</span>
</span><span class="hll">      <span class="nx">prevPage</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span> else <span class="p">{</span>
</span>      <span class="kr">const</span> <span class="nx">reverseSort</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_reverseSortDirection</span><span class="p">(</span><span class="nx">sort</span><span class="p">);</span>
      <span class="kr">const</span> <span class="nx">operator</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getOperator</span><span class="p">(</span><span class="nx">reverseSort</span><span class="p">);</span>
      <span class="kr">const</span> <span class="nx">queryDoc</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getFilterWithCursor</span><span class="p">(</span>
        <span class="nx">startCursor</span><span class="p">,</span>
        <span class="nx">filter</span><span class="p">,</span>
        <span class="nx">operator</span><span class="p">,</span>
        <span class="nx">reverseSort</span>
      <span class="p">);</span>

<span class="hll">      <span class="nx">prevPage</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">findOne</span><span class="p">(</span><span class="nx">queryDoc</span><span class="p">)</span>
</span>        <span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="nx">reverseSort</span><span class="p">);</span>
<span class="hll">    <span class="p">}</span>
</span>
    <span class="k">return</span> <span class="nb">Boolean</span><span class="p">(</span><span class="nx">prevPage</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Pagination</span><span class="p">;</span>
</pre></div>

<p>Notice the change to the call to <code>_getOperator</code> now—we pass in the optional <code>options</code> object that indicates whether we are dealing with a search query (setting <code>checkPreviousTextScore</code> to <code>true</code>) and we check if there are any previous results before the current page of search results (using the <code>$gt</code> operator for this instead).</p>
<p>At long last, our <code>Pagination</code> class is complete! We can now update the <code>searchProfiles</code> method in the <code>ProfilesDataSource</code> class to use the updated pagination methods:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/dataSources/ProfilesDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">class</span> <span class="nx">ProfilesDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">async</span> <span class="nx">searchProfiles</span><span class="p">({</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">searchString</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">score</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$meta</span><span class="o">:</span> <span class="s2">&quot;textScore&quot;</span> <span class="p">},</span> <span class="nx">_id</span><span class="o">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">filter</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">$text</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$search</span><span class="o">:</span> <span class="nx">searchString</span> <span class="p">}</span> <span class="p">};</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">queryArgs</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">filter</span><span class="p">,</span> <span class="nx">sort</span> <span class="p">};</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">edges</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">pagination</span><span class="p">.</span><span class="nx">getEdges</span><span class="p">(</span><span class="nx">queryArgs</span><span class="p">);</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">pageInfo</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">pagination</span><span class="p">.</span><span class="nx">getPageInfo</span><span class="p">(</span><span class="nx">edges</span><span class="p">,</span> <span class="nx">queryArgs</span><span class="p">);</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="p">{</span> <span class="nx">edges</span><span class="p">,</span> <span class="nx">pageInfo</span> <span class="p">};</span>
</span>  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">ProfilesDataSource</span><span class="p">;</span>
</pre></div>

<p>Be sure to mark this method as <code>async</code> now and also update the parameter to be an object rather than the <code>searchString</code> alone. As a final step, we will update the <code>searchProfiles</code> resolver in <code>resolvers.js</code>:</p>
<p></p>
<div class="code-context">
<p>profiles/src/graphql/resolvers.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">const</span> <span class="nx">resolvers</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">Query</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="hll">    <span class="nx">searchProfiles</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="p">{</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">query</span> <span class="p">}</span>, <span class="p">{</span> <span class="nx">dataSources</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">profilesAPI</span><span class="p">.</span><span class="nx">searchProfiles</span><span class="p">({</span>
</span><span class="hll">        <span class="nx">after</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">first</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">searchString</span><span class="o">:</span> <span class="nx">query</span>
</span><span class="hll">      <span class="p">});</span>
</span>    <span class="p">}</span>
  <span class="p">},</span>

  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">resolvers</span><span class="p">;</span>
</pre></div>

<p>Now test the query:</p>
<p></p>
<div class="code-context">
<p>GraphQL Query</p>
</div>
<div class="highlight"><pre><span></span><span class="kt">query</span> <span class="k">SearchProfiles</span><span class="p">(</span><span class="nv">$query</span><span class="p">:</span> <span class="k">String</span><span class="p">!</span>, <span class="nv">$first</span><span class="p">:</span> <span class="k">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">searchProfiles</span><span class="p">(</span>query: <span class="nv">$query</span>, first: <span class="nv">$first</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">edges</span> <span class="p">{</span>
      <span class="k">node</span> <span class="p">{</span>
        <span class="k">username</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pageInfo</span> <span class="p">{</span>
      <span class="k">hasPreviousPage</span>
      <span class="k">hasNextPage</span>
      <span class="k">startCursor</span>
      <span class="k">endCursor</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>Query Variables</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;query&quot;</span><span class="p">:</span> <span class="s2">&quot;ada hopper&quot;</span><span class="p">,</span>
  <span class="nt">&quot;first&quot;</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">}</span>
</pre></div>

<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;data&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;searchProfiles&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;grace_hopper&quot;</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&quot;node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;ada_lovelace&quot;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">],</span>
      <span class="nt">&quot;pageInfo&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;hasPreviousPage&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="nt">&quot;hasNextPage&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="nt">&quot;startCursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed69a52707218760b0128&quot;</span><span class="p">,</span>
        <span class="nt">&quot;endCursor&quot;</span><span class="p">:</span> <span class="s2">&quot;625ed5a652707218760b0122&quot;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="summary">Summary</h2>
<p>In this chapter, we dove into the mechanics of the Relay Connection Cursor Specification and had the opportunity to implement it against data stored in MongoDB. We began by creating a <code>Pagination</code> class containing various generalized methods to pull paginated data from a MongoDB collection.</p>
<p>We then updated the profiles service’s type definitions and used those methods in the <code>ProfilesDataSource</code> to paginate the <code>network</code> field on the <code>Profile</code> type, and then added pagination to the <code>profiles</code> and <code>searchProfiles</code> fields on the root <code>Query</code> type. Paginating the search query also provided a chance to explore an advanced feature of MongoDB called aggregation.</p>
<p>While implementing Relay-style pagination was an lengthy undertaking, all of our hard work here will pay dividends in the next chapter where we’ll reuse the <code>Pagination</code> class once again as we build out the bookmarks service.</p>
<footer>
<p class="copyright">Copyright © 2022 <a href="https://8bit.press/">8-Bit Press Inc.</a> All rights reserved.</p>
</footer>
</div>
</div>
<script>
(function () {
  "use strict";

  const chapter = document.getElementById("chapter");

  // Set width of fixed-position chapter navigation based on parent
  function setChapterNavWidth() {
    const chapterNav = document.getElementsByClassName("chapter-nav")[0];
    let { width: chapterWidth } = chapter.getBoundingClientRect();
    chapterNav.setAttribute(
      "style",
      `width: ${chapterWidth >= 960 ? chapterWidth * 0.3 + 36 + "px" : "100%"}`
    );
  }

  setChapterNavWidth();
  window.addEventListener("resize", setChapterNavWidth);

  // Open and close the book navigation in the masthead
  const openMastheadButton = document.getElementById("masthead-open");
  const closeMastheadButton = document.getElementById("masthead-close");
  const masthead = document.getElementById("masthead");

  openMastheadButton.addEventListener("click", function (event) {
    event.stopPropagation();
    masthead.style.marginLeft = "0px";
  });

  closeMastheadButton.addEventListener("click", function () {
    masthead.style.marginLeft = "-100%";
  });

  chapter.addEventListener("click", function () {
    if (masthead.style.marginLeft === "0px") {
      masthead.style.marginLeft = "-100%";
    }
  });

  // Add "Copy" button to code snippets
  // Reference: https://tomspencer.dev/blog/2018/09/14/adding-click-to-copy-buttons-to-a-hugo-powered-blog/
  if (!document.queryCommandSupported("copy")) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.textContent = msg;
    setTimeout(function () {
      el.textContent = "Copy";
    }, 1000);
  }

  function selectText(node) {
    const selection = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    const copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn";
    copyBtn.textContent = "Copy";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener("click", function () {
      try {
        const selection = selectText(codeEl);
        document.execCommand("copy");
        selection.removeAllRanges();

        flashCopyMessage(copyBtn, "Copied!");
      } catch (e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, "Failed :'(");
      }
    });

    containerEl.appendChild(copyBtn);
  }

  // Add copy button to code blocks
  var highlightBlocks = document.getElementsByClassName("highlight");
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>
</body>
</html>