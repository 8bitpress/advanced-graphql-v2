<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <link rel="icon" href="../../images/favicon.ico" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mandi Wise" />
  <title>Advanced GraphQL with Apollo</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../../css/web.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div id="masthead">
<div class="close-button-wrapper">
<button id="masthead-close" type="button"><span>Close</span></button>
</div>
<header id="title-block-header">
<h1 class="title">Advanced GraphQL with Apollo</h1>
<p class="subtitle">Build a Distributed GraphQL API with Apollo Federation 2 and Apollo Server</p>
<p class="author">Mandi Wise</p>
</header>
<nav class="book-nav">
<ol class="front-matter-content">
<li><a href="../preface/index.html">Preface</a></li>
</ol>
<ol class="main-matter-content">
<li><a href="../chapter-01/index.html">Apollo Federation and Gateway</a></li>
<li><a href="../chapter-02/index.html">Authentication and User Account Management with Auth0</a></li>
<li><a href="../chapter-03/index.html">Apollo Data Sources, Custom Scalars, and Custom Directives</a></li>
<li><a href="../chapter-04/index.html">User Metadata Management with MongoDB and Mongoose</a></li>
<li><a href="../chapter-05/index.html">Relay-Style Pagination</a></li>
<li><a href="../chapter-06/index.html">Bookmark Management with MongoDB and Mongoose</a></li>
<li><a href="../chapter-07/index.html">API Performance and Security Considerations</a></li>
<li><a href="../chapter-08/index.html">Multi-Subgraph Workflows with Temporal</a></li>
<li><a href="../chapter-09/index.html">Managed Federation with Apollo Studio</a></li>
<li><a href="../chapter-10/index.html">Apollo Router</a></li>
</ol>
<ol class="back-matter-content">
<li><a href="../about-the-author/index.html">About the Author</a></li>
<li><a href="../changelog/index.html">Changelog</a></li>
</ol>
<img src="../../images/8bp-logo-white.svg" class="logo" alt="8-Bit Press Inc. logo" />
</nav>
</div>
<div id="chapter">
<div class="chapter-nav">
<nav id="TOC" role="doc-toc">
<button id="masthead-open" type="button"><span>Book Navigation</span></button>
<h2 id="toc-title">Contents</h2>
<ul>
<li><a href="#apollo-data-sources-custom-scalars-and-custom-directives">Chapter 3: Apollo Data Sources, Custom Scalars, and Custom Directives</a>
<ul>
<li><a href="#manage-data-fetching-logic-in-an-apollo-data-source">Manage Data-Fetching Logic in an Apollo Data Source</a></li>
<li><a href="#add-a-custom-datetime-scalar-type">Add a Custom <code>DateTime</code> Scalar Type</a></li>
<li><a href="#approaches-to-authorization-in-graphql">Approaches to Authorization in GraphQL</a></li>
<li><a href="#custom-directives-with-apollo-federation">Custom Directives with Apollo Federation</a></li>
<li><a href="#handling-authorization-with-type-system-directives">Handling Authorization with Type System Directives</a></li>
<li><a href="#securing-references-resolvers">Securing References Resolvers</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
</ul>
</nav>
</div>
<div class="content">
<h1 id="apollo-data-sources-custom-scalars-and-custom-directives">Chapter 3: Apollo Data Sources, Custom Scalars, and Custom Directives</h1>
<div class="boxout">
<p>In this chapter, we will:</p>
<ul>
<li>Refactor data-fetching logic from resolvers into an Apollo data source</li>
<li>Create a library to facilitate sharing of types and directives across subgraph schemas</li>
<li>Add a custom <code>DateTime</code> Scalar type</li>
<li>Add custom type system directives to manage field-level authorization</li>
</ul>
</div>
<h2 id="manage-data-fetching-logic-in-an-apollo-data-source">Manage Data-Fetching Logic in an Apollo Data Source</h2>
<p>At the moment, the <code>resolvers.js</code> file for the accounts service is a bit messy. This mess has accumulated here because all of the logic for making requests to the Auth0 Management API is handled directly in the resolver code blocks. If this service’s schema continues to grow in the future, then this file may become unwieldy.</p>
<p>A better practice would be to encapsulate all of our data-fetching logic for the service elsewhere. Apollo Server provides us with a built-in way to do this using a <em>data source</em>. An Apollo data source can also provide mechanisms for caching, de-duplication, and error handling of requests made to some source of data like a REST API. As a bonus, we’ll see that an Apollo data source will help make the data-fetching code in the resolvers DRYer and make it easier for us to integrate the DataLoader library in Chapter 7.</p>
<p>To create a data source, we will extend Apollo Server’s <code>DataSource</code> class and add methods inside of it that fetch data from the Auth0 Management API. Once it’s created, we’ll add it to Apollo Server’s <code>context</code> object so that the data source methods are available to all resolvers.</p>
<p>Adding an Apollo data source will require some refactoring in the <code>resolvers.js</code> file now (for future services, we’ll use data sources from the get-go to avoid this). We’ll start by installing the <code>apollo-datasource</code> package in <code>accounts</code>:</p>
<p></p>
<div class="code-context">
<p>accounts/</p>
</div>
<div class="highlight"><pre><span></span>npm i apollo-datasource@3.3.1
</pre></div>

<p>Next, we’ll create a subdirectory called <code>dataSources</code> in <code>accounts/src/graphql</code> and add an <code>AccountsDataSource.js</code> file to it with the following initial code:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/dataSources/AccountsDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">DataSource</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-datasource&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">AccountsDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">({</span> <span class="nx">auth0</span> <span class="p">})</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">auth0</span> <span class="o">=</span> <span class="nx">auth0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Data-fetching methods will go here...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">AccountsDataSource</span><span class="p">;</span>
</pre></div>

<p>We pass <code>auth0</code> into the constructor and set it as a property because when we instantiate our data source later we’ll pass in our Auth0 configuration so we have access to the Management API client. This change means that wherever we called an <code>auth0</code> method in a resolver previously we’ll need to update it to <code>this.auth0</code> now as we refactor that code and add it to the <code>AccountsDataSource</code>.</p>
<p>Now we’ll migrate the data-fetching code in the resolvers into some methods for this class. We’ll begin by adding a <code>createAccount</code> method that has <code>email</code> and <code>password</code> parameters to support user account creation in Auth0:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/dataSources/AccountsDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">DataSource</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-datasource&quot;</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">AccountsDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="hll">
</span><span class="hll">  <span class="nx">createAccount</span><span class="p">(</span><span class="nx">email</span><span class="p">,</span> <span class="nx">password</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">auth0</span><span class="p">.</span><span class="nx">createUser</span><span class="p">({</span>
</span><span class="hll">      <span class="nx">connection</span><span class="o">:</span> <span class="s2">&quot;Username-Password-Authentication&quot;</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">email</span><span class="p">,</span>
</span><span class="hll">      <span class="nx">password</span>
</span><span class="hll">    <span class="p">});</span>
</span><span class="hll">  <span class="p">}</span>
</span><span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">AccountsDataSource</span><span class="p">;</span>
</pre></div>

<p>Again, note that we call Auth0’s <code>createUser</code> method on <code>this.auth0</code> now. Next, we’ll add methods to support email and password updates. To do that, we must move the <code>UserInputError</code> and <code>getToken</code> imports from the <code>resolvers.js</code> file to <code>AccountsDataSource.js</code> because we’ll do the token fetching and error handling here instead:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/dataSources/AccountsDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">DataSource</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-datasource&quot;</span><span class="p">;</span>
<span class="hll"><span class="kr">import</span> <span class="p">{</span> <span class="nx">UserInputError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll"><span class="kr">import</span> <span class="nx">getToken</span> <span class="nx">from</span> <span class="s2">&quot;../../utils/getToken.js&quot;</span><span class="p">;</span>
</span>
<span class="c1">// ...</span>
</pre></div>

<p>Now we can add <code>updateAccountEmail</code> and <code>updateAccountPassword</code> methods:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/dataSources/AccountsDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">class</span> <span class="nx">AccountsDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="hll">
</span><span class="hll">  <span class="nx">updateAccountEmail</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">email</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">auth0</span><span class="p">.</span><span class="nx">updateUser</span><span class="p">({</span> <span class="nx">id</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">email</span> <span class="p">});</span>
</span><span class="hll">  <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">  <span class="nx">async</span> <span class="nx">updateAccountPassword</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">newPassword</span><span class="p">,</span> <span class="nx">password</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="kr">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">auth0</span><span class="p">.</span><span class="nx">getUser</span><span class="p">({</span> <span class="nx">id</span> <span class="p">});</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">try</span> <span class="p">{</span>
</span><span class="hll">      <span class="nx">await</span> <span class="nx">getToken</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">email</span><span class="p">,</span> <span class="nx">password</span><span class="p">);</span>
</span><span class="hll">    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">UserInputError</span><span class="p">(</span><span class="s2">&quot;Email or existing password is incorrect.&quot;</span><span class="p">);</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">auth0</span><span class="p">.</span><span class="nx">updateUser</span><span class="p">({</span> <span class="nx">id</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">password</span><span class="o">:</span> <span class="nx">newPassword</span> <span class="p">});</span>
</span><span class="hll">  <span class="p">}</span>
</span><span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">AccountsDataSource</span><span class="p">;</span>
</pre></div>

<p>Lastly, we’ll create a <code>deleteAccount</code> method, giving it an <code>id</code> parameter</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/dataSources/AccountsDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">class</span> <span class="nx">AccountsDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="hll">
</span><span class="hll">  <span class="nx">async</span> <span class="nx">deleteAccount</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">try</span> <span class="p">{</span>
</span><span class="hll">      <span class="nx">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">auth0</span><span class="p">.</span><span class="nx">deleteUser</span><span class="p">({</span> <span class="nx">id</span> <span class="p">});</span>
</span><span class="hll">      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">  <span class="p">}</span>
</span><span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">AccountsDataSource</span><span class="p">;</span>
</pre></div>

<p>Apart from the write operations, we also need methods to read data from Auth0 in this data source. The first method will be called <code>getAccountById</code>:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/dataSources/AccountsDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">class</span> <span class="nx">AccountsDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">getAccountById</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">auth0</span><span class="p">.</span><span class="nx">getUser</span><span class="p">({</span> <span class="nx">id</span> <span class="p">});</span>
</span><span class="hll">  <span class="p">}</span>
</span><span class="hll">
</span>  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">AccountsDataSource</span><span class="p">;</span>
</pre></div>

<p>This method will work in both the <code>account</code> and <code>viewer</code> resolvers because these two resolvers fetch the same kind of data and in the same way, but with ID arguments originating from different sources (the <code>account</code> query has a user-supplied <code>id</code> argument while <code>viewer</code> uses the decoded JWT to get the account ID).</p>
<p>Lastly, we’ll create the accompanying <code>getAccounts</code> method:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/dataSources/AccountsDataSource.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">class</span> <span class="nx">AccountsDataSource</span> <span class="kr">extends</span> <span class="nx">DataSource</span> <span class="p">{</span>
  <span class="c1">// ...</span>

<span class="hll">  <span class="nx">getAccounts</span><span class="p">()</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">auth0</span><span class="p">.</span><span class="nx">getUsers</span><span class="p">();</span>
</span><span class="hll">  <span class="p">}</span>
</span><span class="hll">
</span>  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">AccountsDataSource</span><span class="p">;</span>
</pre></div>

<p>Now that we’ve created our data source we need to add it to the accounts service’s Apollo Server <code>context</code>. First, we’ll import the <code>AccountsDataSource</code> class into the <code>index.js</code> file. Because we pass the <code>auth0</code> client into the <code>AccountsDataSource</code> constructor, we need to import it here too:</p>
<p></p>
<div class="code-context">
<p>accounts/src/index.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="hll"><span class="kr">import</span> <span class="nx">AccountsDataSource</span> <span class="nx">from</span> <span class="s2">&quot;./graphql/dataSources/AccountsDataSource.js&quot;</span><span class="p">;</span>
</span><span class="hll"><span class="kr">import</span> <span class="nx">auth0</span> <span class="nx">from</span> <span class="s2">&quot;./config/auth0.js&quot;</span><span class="p">;</span>
</span><span class="kr">import</span> <span class="nx">resolvers</span> <span class="nx">from</span> <span class="s2">&quot;./resolvers.js&quot;</span><span class="p">;</span>

<span class="c1">// ...</span>
</pre></div>

<p>Next, we can instantiate a new <code>AccountsDataSource</code> object and pass in the <code>auth0</code> client to it. As mentioned previously, the data source will be available in the <code>context</code> of the resolvers. Rather than adding it imperatively to the context, we set a dedicated <code>dataSources</code> option in the <code>ApolloServer</code> constructor. This method returns an object containing all of the data sources we want to access from our resolver functions:</p>
<p></p>
<div class="code-context">
<p>accounts/src/index.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ApolloServer</span><span class="p">({</span>
  <span class="nx">schema</span><span class="o">:</span> <span class="nx">buildSubgraphSchema</span><span class="p">({</span> <span class="nx">typeDefs</span><span class="p">,</span> <span class="nx">resolvers</span> <span class="p">}),</span>
  <span class="nx">context</span><span class="o">:</span> <span class="p">({</span> <span class="nx">req</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">user</span> <span class="o">?</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">user</span><span class="p">)</span> <span class="o">:</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">user</span> <span class="p">};</span>
<span class="hll">  <span class="p">},</span>
</span><span class="hll">  <span class="nx">dataSources</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">return</span> <span class="p">{</span>
</span><span class="hll">      <span class="nx">accountsAPI</span><span class="o">:</span> <span class="k">new</span> <span class="nx">AccountsDataSource</span><span class="p">({</span> <span class="nx">auth0</span> <span class="p">})</span>
</span><span class="hll">    <span class="p">};</span>
</span>  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// ...</span>
</pre></div>

<p>With this code in place, we can access the <code>AccountsDataSource</code> methods in the resolvers. To do this, we destructure the <code>dataSources</code> object from the resolver’s <code>context</code> parameter. From there, the methods we created can be called from <code>accountsAPI</code> object nested inside it. We’ll update the field resolvers for the root <code>Query</code> type first:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/resolvers.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">const</span> <span class="nx">resolvers</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">Query</span><span class="o">:</span> <span class="p">{</span>
<span class="hll">    <span class="nx">account</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="p">{</span> <span class="nx">id</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">dataSources</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">accountsAPI</span><span class="p">.</span><span class="nx">getAccountById</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
</span>    <span class="p">},</span>
<span class="hll">    <span class="nx">accounts</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="p">{</span> <span class="nx">dataSources</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">accountsAPI</span><span class="p">.</span><span class="nx">getAccounts</span><span class="p">();</span>
</span>    <span class="p">},</span>
<span class="hll">    <span class="nx">viewer</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="p">{</span> <span class="nx">dataSources</span><span class="p">,</span> <span class="nx">user</span> <span class="p">})</span> <span class="p">{</span>
</span>      <span class="k">if</span> <span class="p">(</span><span class="nx">user</span><span class="o">?</span><span class="p">.</span><span class="nx">sub</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">accountsAPI</span><span class="p">.</span><span class="nx">getAccountById</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">sub</span><span class="p">);</span>
</span>      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">},</span>

  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">resolvers</span><span class="p">;</span>
</pre></div>

<p>We can even use the <code>getAccountById</code> method in the <code>__resolveReference</code> resolver for the <code>Account</code> entity because the <code>context</code> object is available as its the second parameter:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/resolvers.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">const</span> <span class="nx">resolvers</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">Account</span><span class="o">:</span> <span class="p">{</span>
<span class="hll">    <span class="nx">__resolveReference</span><span class="p">(</span><span class="nx">reference</span><span class="p">,</span> <span class="p">{</span> <span class="nx">dataSources</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">accountsAPI</span><span class="p">.</span><span class="nx">getAccountById</span><span class="p">(</span><span class="nx">reference</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
</span>    <span class="p">},</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">resolvers</span><span class="p">;</span>
</pre></div>

<p>Lastly, we’ll update the <code>Mutation</code> resolvers:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/resolvers.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">const</span> <span class="nx">resolvers</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nx">Mutation</span><span class="o">:</span> <span class="p">{</span>
<span class="hll">    <span class="nx">createAccount</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="p">{</span> <span class="nx">input</span><span class="o">:</span> <span class="p">{</span> <span class="nx">email</span><span class="p">,</span> <span class="nx">password</span> <span class="p">}</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">dataSources</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">accountsAPI</span><span class="p">.</span><span class="nx">createAccount</span><span class="p">(</span><span class="nx">email</span><span class="p">,</span> <span class="nx">password</span><span class="p">);</span>
</span>    <span class="p">},</span>
<span class="hll">    <span class="nx">deleteAccount</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="p">{</span> <span class="nx">id</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">dataSources</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">accountsAPI</span><span class="p">.</span><span class="nx">deleteAccount</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
</span>    <span class="p">},</span>
<span class="hll">    <span class="nx">updateAccountEmail</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="p">{</span> <span class="nx">input</span><span class="o">:</span> <span class="p">{</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">email</span> <span class="p">}</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">dataSources</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">accountsAPI</span><span class="p">.</span><span class="nx">updateAccountEmail</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">email</span><span class="p">);</span>
</span>    <span class="p">},</span>
<span class="hll">    <span class="nx">updateAccountPassword</span><span class="p">(</span>
</span><span class="hll">      <span class="nx">root</span><span class="p">,</span>
</span><span class="hll">      <span class="p">{</span> <span class="nx">input</span><span class="o">:</span> <span class="p">{</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">newPassword</span><span class="p">,</span> <span class="nx">password</span> <span class="p">}</span> <span class="p">},</span>
</span><span class="hll">      <span class="p">{</span> <span class="nx">dataSources</span> <span class="p">}</span>
</span><span class="hll">    <span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">accountsAPI</span><span class="p">.</span><span class="nx">updateAccountPassword</span><span class="p">(</span>
</span><span class="hll">        <span class="nx">id</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">newPassword</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">password</span>
</span><span class="hll">      <span class="p">);</span>
</span>    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">resolvers</span><span class="p">;</span>
</pre></div>

<p>Take note that the <code>deleteAccount</code> and <code>updateAccountPassword</code> resolvers no longer need to be <code>async</code> because they will just return the promise returned by their respective data source methods. Additionally, because our resolvers are now fully refactored to use the data source, we can delete the <code>auth0</code> import at the top of <code>resolvers.js</code> too as we will no longer need direct access to it here. Before moving on, you’ll want to retest all of the accounts service’s queries and mutations in Explorer to make sure they still work as they did before refactoring.</p>
<h2 id="add-a-custom-datetime-scalar-type">Add a Custom <code>DateTime</code> Scalar Type</h2>
<p>GraphQL has <code>Int</code>, <code>Float</code>, <code>String</code>, <code>Boolean</code>, and <code>ID</code> Scalar types by default, but sometimes these built-in types aren’t quite enough! When warranted, we can add a custom Scalar type with a workflow that we already know well—in other words, we’ll define a type in the schema and then write a resolver so that the type will be handled as desired during GraphQL execution.</p>
<p>We’re going to add a custom <code>DateTime</code> Scalar type to our schema and use it as an output type for the <code>createdAt</code> field. While we can be reasonably confident that Auth0 will provide us with date values that are in a valid ISO 8601 format, the <code>DateTime</code> Scalar will provide an extra measure of certainty and transparency for the consumers of our API that they will receive a date string in this precise format. This Scalar type will also be a convenient way to enforce consistency for all date-related fields across the different subgraphs we create.</p>
<p>Federation 2 offers more flexibility than the Federation 1 specification did when it comes to sharing non-entity types across subgraphs. We’ll explore some of these features in more depth in Chapter 5, but for now, all that we need to know is that multiple subgraphs can define and use the same custom Scalar types. But it’s up to the teams that own the subgraph schemas to ensure that they implement consistent serialization and parsing logic for the Scalar type to ensure predictability for the clients that send requests to the API.</p>
<p>To that end, we’re going to create a library to contain shared custom type definitions so that we can use them consistently across subgraph schemas without having to redefine them explicitly in each one. For brevity’s sake, we will keep these definitions in a sibling directory called <code>shared</code> alongside the <code>accounts</code> and <code>gateway</code> directories in our project. However, we could imagine that this library would exist in a separate repository and would be installed as a dependency in any Node.js-based subgraphs.</p>
<p>Create a subdirectory called <code>shared</code> in the root project directory and add a <code>package.json</code> file to it:</p>
<p></p>
<div class="code-context">
<p>shared/</p>
</div>
<div class="highlight"><pre><span></span>npm init --yes
</pre></div>

<p>Next, we’ll opt into using <code>import</code>/<code>export</code> syntax and also set the entry point for this module:</p>
<p></p>
<div class="code-context">
<p>shared/package.json</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="c1">// ...</span>
<span class="hll">  <span class="s2">&quot;type&quot;</span><span class="o">:</span> <span class="s2">&quot;module&quot;</span><span class="p">,</span>
</span><span class="hll">  <span class="s2">&quot;main&quot;</span><span class="o">:</span> <span class="s2">&quot;src/index.js&quot;</span><span class="p">,</span>
</span>  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>

<p>We’ll need to install a few familiar packages in <code>shared</code> to support the <code>DateTime</code> Scalar, and we will also need the <code>validator</code> package to assist with date string validation:</p>
<div class="highlight"><pre><span></span>npm i apollo-server@3.7.0 graphql@16.5.0 validator@13.7.0
</pre></div>

<p>Next, we’ll add a <code>src</code> subdirectory inside of <code>shared</code> and then a <code>scalars</code> subdirectory inside of <code>src</code> with a <code>DateTypeType.js</code> file in it that contains the following initial code:</p>
<p></p>
<div class="code-context">
<p>shared/src/scalars/DateTimeType.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">ApolloError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">GraphQLScalarType</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;graphql&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">validator</span> <span class="nx">from</span> <span class="s2">&quot;validator&quot;</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">DateTimeType</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GraphQLScalarType</span><span class="p">({</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;DateTime&quot;</span><span class="p">,</span>
  <span class="nx">description</span><span class="o">:</span> <span class="s2">&quot;An ISO 8601-encoded UTC date string.&quot;</span>
  <span class="c1">// Date string validation logic will go here...</span>
<span class="p">});</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">DateTimeType</span><span class="p">;</span>
</pre></div>

<p>The value of <code>DateTimeResolver</code> must be a newly instantiated <code>GraphQLScalarType</code> object. This constructor expects us to pass in an object with a <code>name</code> and a <code>description</code> for the custom Scalar type. In addition to that, we have to create three methods that set the rules for the expected input and output values:</p>
<ul>
<li><code>parseValue</code> ensures the value sent <em>from</em> the client is a valid date string</li>
<li><code>serialize</code> ensures the value to be sent <em>to</em> the client is a valid date string</li>
<li><code>parseLiteral</code> ensures the GraphQL abstract syntax tree (AST) value is a valid date string</li>
</ul>
<p>To do this validation, our final <code>DateTimeType</code> will look like this:</p>
<p></p>
<div class="code-context">
<p>shared/src/scalars/DateTimeType.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kr">const</span> <span class="nx">DateTimeType</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GraphQLScalarType</span><span class="p">({</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;DateTime&quot;</span><span class="p">,</span>
<span class="hll">  <span class="nx">description</span><span class="o">:</span> <span class="s2">&quot;An ISO 8601-encoded UTC date string.&quot;</span><span class="p">,</span>
</span><span class="hll">  <span class="nx">parseValue</span><span class="o">:</span> <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="nx">validator</span><span class="p">.</span><span class="nx">isISO8601</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">    <span class="k">throw</span> <span class="k">new</span> <span class="nx">ApolloError</span><span class="p">(</span><span class="s2">&quot;DateTime must be a valid ISO 8601 Date string&quot;</span><span class="p">);</span>
</span><span class="hll">  <span class="p">},</span>
</span><span class="hll">  <span class="nx">serialize</span><span class="o">:</span> <span class="nx">value</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">!==</span> <span class="s2">&quot;string&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">      <span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toISOString</span><span class="p">();</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="nx">validator</span><span class="p">.</span><span class="nx">isISO8601</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">    <span class="k">throw</span> <span class="k">new</span> <span class="nx">ApolloError</span><span class="p">(</span><span class="s2">&quot;DateTime must be a valid ISO 8601 Date string&quot;</span><span class="p">);</span>
</span><span class="hll">  <span class="p">},</span>
</span><span class="hll">  <span class="nx">parseLiteral</span><span class="o">:</span> <span class="nx">ast</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="nx">validator</span><span class="p">.</span><span class="nx">isISO8601</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">return</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">    <span class="k">throw</span> <span class="k">new</span> <span class="nx">ApolloError</span><span class="p">(</span><span class="s2">&quot;DateTime must be a valid ISO 8601 Date string&quot;</span><span class="p">);</span>
</span><span class="hll">  <span class="p">}</span>
</span><span class="p">});</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">DateTimeType</span><span class="p">;</span>
</pre></div>

<p>When we serialize the data to be sent to the client we do an extra check to see if the value is a string first. We do this check here because later on we’ll see that dates are stored as <code>Date</code> objects in MongoDB, and we’ll need to convert those objects to ISO 8601 date strings before we run a function to confirm that they are in the correct format.</p>
<p>We have one last thing to do in <code>shared</code>, which is to configure the main entry point for this library, which will be an <code>index.js</code> file in <code>src</code>:</p>
<p></p>
<div class="code-context">
<p>shared/src/index.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">DateTimeType</span> <span class="nx">from</span> <span class="s2">&quot;./scalars/DateTimeType.js&quot;</span><span class="p">;</span>

<span class="kr">export</span> <span class="p">{</span> <span class="nx">DateTimeType</span> <span class="p">};</span>
</pre></div>

<p>Now we’re ready to define the <code>DateTime</code> Scalar type in the accounts service’s schema and use it as the output type for the <code>createdAt</code> field:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/schema.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Singline"># ...</span>

<span class="hll"><span class="k">scalar</span> <span class="k">DateTime</span>
</span>
<span class="c c-Multi">&quot;&quot;&quot;</span>
<span class="c c-Multi">An account is a unique Auth0 user.</span>
<span class="c c-Multi">&quot;&quot;&quot;</span>
<span class="kt">type</span> <span class="k">Account</span> <span class="kt">@key</span><span class="p">(</span>fields: <span class="s2">&quot;id&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="s2">&quot;The unique ID associated with the account.&quot;</span>
  id: <span class="k">ID</span><span class="p">!</span>
  <span class="s2">&quot;The date and time the account was created.&quot;</span>
<span class="hll">  createdAt: <span class="k">DateTime</span><span class="p">!</span>
</span>  <span class="s2">&quot;The email associated with the account (must be unique).&quot;</span>
  email: <span class="k">String</span><span class="p">!</span>
<span class="p">}</span>

<span class="c c-Singline"># ...</span>
</pre></div>

<p>Like most things in a GraphQL schema, the custom Scalar type needs to be represented in this subgraph’s map of resolvers. It’s worth noting again that the code in the <code>shared</code> directory would likely live in a distinct package that could be installed in any Node.js-based subgraph. For instructional purposes, we will keep things simple and just relatively import the <code>DateTimeType</code> from <code>shared</code> into the accounts service’s <code>resolvers.js</code> file:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/resolvers.js</p>
</div>
<div class="highlight"><pre><span></span><span class="hll"><span class="kr">import</span> <span class="p">{</span> <span class="nx">DateTimeType</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;../../../shared/src/index.js&quot;</span><span class="p">;</span>
</span>
<span class="kr">const</span> <span class="nx">resolvers</span> <span class="o">=</span> <span class="p">{</span>
<span class="hll">  <span class="nx">DateTime</span><span class="o">:</span> <span class="nx">DateTimeType</span><span class="p">,</span>
</span><span class="hll">  
</span>  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">resolvers</span><span class="p">;</span>
</pre></div>

<p>Before testing the new output type for the <code>createdAt</code> field, we’ll preemptively deal with an error that we will encounter due to how our <code>shared</code> module is configured locally. Both the <code>accounts</code> and <code>shared</code> directories have the graphql.js package installed. If we leave things as they are, we will eventually encounter an error like this one while running the accounts service:</p>
<div class="highlight"><pre><span></span>Error: Cannot use GraphQLObjectType &quot;SomeTypeName&quot; from another module or realm.

Ensure that there is only one instance of `graphql` in the node_modules directory. If different versions of `graphql` are the dependencies of other relied-on modules, use &quot;resolutions&quot; to ensure only one version is installed.
</pre></div>

<p>If the <code>shared</code> library was truly an independent module, then the <code>graphql</code> package would be deduped when installed. However, we have loaded it relatively here instead so from the accounts service’s perspective we are trying to load two versions of this package, resulting in the above error. The solution to this problem for our development environment is to use <code>npm link</code> to create two symbolic links. The first step is to <code>cd</code> into <code>shared/node_modules/graphql</code> and run the following command:</p>
<p></p>
<div class="code-context">
<p>shared/node_modules/graphql</p>
</div>
<div class="highlight"><pre><span></span>npm link
</pre></div>

<p>Doing this creates a symlink in the global <code>node_modules</code> directory that links to the package where the <code>npm link</code> command was executed. In other words, we can use the local <code>graphql</code> module installed in <code>shared/node_modules</code> as a global node module elsewhere, such as in the accounts service.</p>
<p>You can confirm that the package was successfully linked by running this command:</p>
<div class="highlight"><pre><span></span>npm ls -g --depth<span class="o">=</span><span class="m">0</span> --link<span class="o">=</span><span class="nb">true</span>
</pre></div>

<p>Next, we need to create a symlink in the <code>accounts</code> directory that points to the previously linked <code>graphql</code> module:</p>
<p></p>
<div class="code-context">
<p>accounts/</p>
</div>
<div class="highlight"><pre><span></span>npm link graphql
</pre></div>

<div class="boxout">
<p>As you continue to work through this book, you may find that you need to relink <code>graphql</code> after installing other dependencies in the service directories. You will know you need to do this whenever you see <code>Error: Cannot use GraphQLObjectType "SomeTypeName" from another module or realm.</code> in the terminal when you try to restart the service. Just run <code>npm link graphql</code> again in the service directory and the error will be fixed.</p>
<p>Additionally, if you want to intentionally remove the symlinks you just created, you can run <code>npm unlink --no-save graphql</code> in the <code>accounts</code> directory first, and then <code>npm unlink</code> in <code>shared/node_modules/graphql</code>. The order of those commands matters!</p>
</div>
<p>If we return to Explorer now, then we should see the new <code>DateTime</code> type as the output type for the <code>createdAt</code> field in the API documentation and the accounts-related query operations should work just as they did before.</p>
<h2 id="approaches-to-authorization-in-graphql">Approaches to Authorization in GraphQL</h2>
<p>The next addition to our library of shared types will be custom type system directives that apply field-level authorization to a selection of fields in the accounts service’s schema. Before we do, let’s pause and consider why we need to do this and what other options we could explore for adding authorization to a GraphQL API.</p>
<p>At the moment, all of the mutations we have written perform user administration tasks in Auth0 and they are fully exposed to anyone who wants to send an operation to our API. Similarly, all of the accounts data is publicly queryable through the API, including the user’s email addresses. In fact, the only field that uses the access token of an authenticated user is the <code>viewer</code> field on the root <code>Query</code> type and that’s just so we can see information about the currently logged-in user (based on the <code>sub</code> claim in the token). No errors will be thrown by any of the queries or mutations if the user making the request isn’t authorized to do so.</p>
<p>But what does being “authorized to do” mean in the Marked application? For the accounts service, it will mean the following:</p>
<ul>
<li>Only authenticated users can query data about other accounts</li>
<li>Only the owner of a given account can update their data or delete the account altogether</li>
</ul>
<p>So that means for the <code>account</code> and <code>accounts</code> queries we’ll need to check for a valid access token before returning any data. Similarly, for the <code>updateAccountEmail</code>, <code>updateAccountPassword</code>, and <code>deleteAccount</code> mutations we’ll need to make sure that the ID corresponding to the account to be updated matches the ID of the authenticated user.</p>
<p>There are several options we can choose from to apply these authorization rules on a per-field basis. Specifically, we could:</p>
<ul>
<li>Write code in every resolver that validates authorization logic for the field before it proceeds with the operation</li>
<li>Use resolver middleware to abstract the authorization logic into a separate layer</li>
<li>Add custom type system directives to validate authorization logic on a query-by-query and mutation-by-mutation basis</li>
</ul>
<p>The first option would likely be a bit tedious so we’ll avoid handling authorization on a per-resolver basis wherever possible (there are a couple of notable exceptions to this that will be called out later in the book). The second option is typically much DRYer than the first and there are packages such as <a href="https://github.com/maticzav/graphql-shield">GraphQL Shield</a> and <a href="https://github.com/AstrumU/graphql-authz">AuthZ</a> that can support this approach. Ultimately, we’ll choose the third option so that we can explore an advanced implementation of custom type system directives at the subgraph level of a federated GraphQL API.</p>
<p>As we move forward through the remainder of the chapter, keep in mind that authorization directives are challenging to implement and there are serious, real-world consequences for doing so incorrectly. Even though our custom directives will end up being quite complex, writing a full-featured series of auth-related directives is outside the scope of this book. However, the code that we write should give you insight into how this task can be approached, provide you with a foundation to build on in the future, and give you a sense of the relative pros and cons of using directives for authorization.</p>
<h2 id="custom-directives-with-apollo-federation">Custom Directives with Apollo Federation</h2>
<p>Before we dive into writing the code for the authorization directives, we need to understand how custom directives work in Apollo Federation, as well as in GraphQL in general. GraphQL has two different kinds of directives—there are <em>type system</em> directives (also known as <em>schema</em> directives) and <em>executable</em> directives (also known as <em>query</em> directives).</p>
<p>Type system directives are used to annotate different elements of an SDL-based schema such as types, fields, and Enum values. Executable directives are used to annotate parts of an operation document such as fragments, field selections, and even an entire query, mutation, or subscription. GraphQL’s built-in <code>@deprecated</code> directive is an example of a type system directive, while the <code>@skip</code> and <code>@include</code> directives are examples of executable directives.</p>
<p>At the time of writing, Apollo Federation provides different kinds of support for custom type system and executable directives. Executable directives can be intercepted by an Apollo Gateway even though Apollo Server itself does not support them. We won’t be adding any executable directives to any of the subgraphs that we create for this API, but it’s good to know that the option is available.</p>
<p>Type system directives, on the other hand, can be applied throughout a subgraph schema just as they would be in a non-federated schema, but a key difference here is that these directives do not roll up to the gateway. In other words, the subgraph will be aware of where the type system directives are located throughout its schema but they will not be present in the supergraph schema because they will be discarded during composition. For most use cases, that will be fine because the subgraph can still apply whatever logic needs to be applied based on the presence of the directive during field resolution.</p>
<p>Lastly, as with any shared definition, when using the same custom type system directive across subgraphs it’s typically a good idea to handle them using consistent logic or ambiguity may result on the client side. Additionally, if multiple subgraphs can resolve the same field for a given type, then each subgraph should also apply the same custom directives with the same handling logic to maintain consistency regardless of where field resolution happens.</p>
<p>As we can see, custom directives should be approached with a certain amount of care and foresight when building a federated graph. But if there is one key takeaway from this discussion, it’s to be consistent and provide predictable results to clients. Importing the authorization directives from a shared library will help satisfy these criteria for the Marked application. However, do keep in mind that if any non-Node.js subgraphs were later composed into the supergraph, then this logic would need to be replicated in that language to use the directives in those subgraphs as well.</p>
<h2 id="handling-authorization-with-type-system-directives">Handling Authorization with Type System Directives</h2>
<p>Before we dive into the code, it should be noted that there are many different approaches we could take to implement authorization directives for a GraphQL API depending on the specific requirements. Our authorization system will be relatively simple in that we won’t need to implement roles or permissions for users. Instead, there are two key things that we may need to verify before a field resolver executes based on a request from an end user:</p>
<ul>
<li><em>Is the user authenticated?</em> If so, then they will have access to certain <code>Query</code> and <code>Mutation</code> fields that should be unavailable to unauthenticated users.</li>
<li><em>Is the user that sent the operation the owner of the resource that they are trying to access or update?</em> If they are not, then they will be barred from viewing or making a change to that resources.</li>
</ul>
<p>In Chapter 9, we’ll add a third consideration when checking custom scopes that will be added to certain JWTs to permit access to various fields for back-end services only. These scopes will not apply to end users of the Marked app so they will not be the focus of this chapter.</p>
<p>We could potentially handle the two authorization criteria listed above in a single <code>@auth</code> directive with a few nullable arguments to handle different authorization scenarios. However, as with fields, including multiple nullable arguments to a generalized directive to accommodate different scenarios can create ambiguity when applying that directive throughout a schema. It also forces runtime code to take care of error-handling logic for non-sensical argument combinations, so it would be a better idea to create more than one directive to serve these specific purposes.</p>
<p>With that in mind, we will create an <code>@private</code> directive to check if an end user is authenticated and an <code>@owner</code> directive to verify that they own a resource before accessing it. As previously mentioned, we will build on the foundation we create in the steps that follow with an additional <code>@scope</code> directive in Chapter 9.</p>
<p>The <a href="https://www.graphql-tools.com/">GraphQL Tools</a> library provides a set of utilities that will support the implementation of our authorization directives, so we’ll install that in <code>shared</code> first:</p>
<p></p>
<div class="code-context">
<p>shared/</p>
</div>
<div class="highlight"><pre><span></span>npm i @graphql-tools/utils@8.6.7
</pre></div>

<p>We’ll define the <code>@private</code> directive first because it’s more straightforward than <code>@owner</code>. We’ll create a <code>directives</code> directory inside of <code>shared/src</code> first and then add an <code>authDirectives.graphql</code> file to it with the following code:</p>
<p></p>
<div class="code-context">
<p>shared/src/directives/authDirectives.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Multi">&quot;&quot;&quot;</span>
<span class="c c-Multi">The user must be authenticated to use the field.</span>
<span class="c c-Multi">&quot;&quot;&quot;</span>
<span class="kt">directive</span> <span class="kt">@private</span> <span class="kt">on</span> <span class="k">FIELD_DEFINITION</span>
</pre></div>

<p>Note that our focus is on field-level authorization so the only valid location for this directive is <code>FIELD_DEFINITION</code>. Next, we’ll create a complimentary <code>authDirectives.js</code> file in the same directory with the following starter code:</p>
<p></p>
<div class="code-context">
<p>shared/src/directives/authDirectives.js</p>
</div>
<div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">dirname</span><span class="p">,</span> <span class="nx">resolve</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;path&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">fileURLToPath</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;url&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">readFileSync</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;fs&quot;</span><span class="p">;</span>

<span class="kr">import</span> <span class="p">{</span> <span class="nx">ApolloError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">defaultFieldResolver</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;graphql&quot;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">getDirectives</span><span class="p">,</span> <span class="nx">MapperKind</span><span class="p">,</span> <span class="nx">mapSchema</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;@graphql-tools/utils&quot;</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">authDirectives</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Return an object containing the auth-related directive definitions</span>
  <span class="c1">// plus a function that will transform Object type fields in the</span>
  <span class="c1">// subgraph schema to handle the directives, where applied</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">authDirectives</span><span class="p">;</span>
</pre></div>

<p>In the code above, we imported the <code>defaultFieldResolver</code> from <code>graphql</code> because the code that we are about to write will wrap the resolver function for any Object type field where one of our authorization directives has been applied. We want to do some authorization checks before the field resolver executes, so when and if these checks pass we must manually call the resolver function inside the wrapping function. If a resolver function hasn’t been provided in the executable schema, then we’ll use the <a href="https://www.apollographql.com/docs/apollo-server/data/resolvers/#default-resolvers">default resolver</a>.</p>
<p>Additionally, we need <code>getDirectives</code> to extract any authorization directives from each field included in an operation, and we will use the <code>mapSchema</code> function and <code>MapperKind</code> to specify what element of the schema we want to transform, which are fields on Object types in this case.</p>
<p>The <code>authDirectives</code> function will return an object with an <code>authDirectivesTypeDefs</code> property that contains the SDL string of directive definitions as well as an <code>authDirecivesTransformer</code> method for a subgraph to apply to its schema so it can execute the directive handling logic:</p>
<p></p>
<div class="code-context">
<p>shared/src/directives/authDirectives.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kd">function</span> <span class="nx">authDirectives</span><span class="p">()</span> <span class="p">{</span>
<span class="hll">  <span class="kr">const</span> <span class="nx">__dirname</span> <span class="o">=</span> <span class="nx">dirname</span><span class="p">(</span><span class="nx">fileURLToPath</span><span class="p">(</span><span class="kr">import</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">url</span><span class="p">));</span>
</span><span class="hll">
</span><span class="hll">  <span class="k">return</span> <span class="p">{</span>
</span><span class="hll">    <span class="nx">authDirectivesTypeDefs</span><span class="o">:</span> <span class="nx">readFileSync</span><span class="p">(</span>
</span><span class="hll">      <span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="s2">&quot;./authDirectives.graphql&quot;</span><span class="p">),</span>
</span><span class="hll">      <span class="s2">&quot;utf-8&quot;</span>
</span><span class="hll">    <span class="p">),</span>
</span><span class="hll">    <span class="nx">authDirectivesTransformer</span><span class="o">:</span> <span class="nx">schema</span> <span class="p">=&gt;</span>
</span><span class="hll">      <span class="nx">mapSchema</span><span class="p">(</span><span class="nx">schema</span><span class="p">,</span> <span class="p">{</span>
</span><span class="hll">        <span class="p">[</span><span class="nx">MapperKind</span><span class="p">.</span><span class="nx">OBJECT_FIELD</span><span class="p">]</span><span class="o">:</span> <span class="nx">fieldConfig</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class="hll">          <span class="c1">// Directive handling logic will go here...</span>
</span><span class="hll">        <span class="p">}</span>
</span><span class="hll">      <span class="p">})</span>
</span><span class="hll">  <span class="p">};</span>
</span><span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">authDirectives</span><span class="p">;</span>
</pre></div>

<p>We will end up handling the logic for all of our authorization directives in this transformer function because we may need to evaluate OR relationships where multiple authorization directives are applied to a single field in some instances (for example, the <code>@owner</code> directive to authorize end users or the <code>@scope</code> directive to authorize authenticated services), but do note that defining one transformer function per custom type system directive is a common pattern.</p>
<p>Next, inside of the transformer function we get the directives for a field by calling <code>getDirectives</code> and then look for the <code>@private</code> directive. We then get the field’s defined resolver or set the default resolver as the <code>resolve</code> value. If the <code>@private</code> directive is present, then we wrap the field resolver with some additional code that checks if there is a validated access token in the <code>context</code>. If there isn’t, then we throw an error, otherwise, we proceed with executing the field resolver:</p>
<p></p>
<div class="code-context">
<p>shared/src/directives/authDirectives.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kd">function</span> <span class="nx">authDirectives</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">__dirname</span> <span class="o">=</span> <span class="nx">dirname</span><span class="p">(</span><span class="nx">fileURLToPath</span><span class="p">(</span><span class="kr">import</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">url</span><span class="p">));</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">authDirectivesTransformer</span><span class="o">:</span> <span class="nx">schema</span> <span class="p">=&gt;</span>
      <span class="nx">mapSchema</span><span class="p">(</span><span class="nx">schema</span><span class="p">,</span> <span class="p">{</span>
        <span class="p">[</span><span class="nx">MapperKind</span><span class="p">.</span><span class="nx">OBJECT_FIELD</span><span class="p">]</span><span class="o">:</span> <span class="nx">fieldConfig</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="hll">          <span class="kr">const</span> <span class="nx">fieldDirectives</span> <span class="o">=</span> <span class="nx">getDirectives</span><span class="p">(</span><span class="nx">schema</span><span class="p">,</span> <span class="nx">fieldConfig</span><span class="p">);</span>
</span><span class="hll">          <span class="kr">const</span> <span class="nx">privateDirective</span> <span class="o">=</span> <span class="nx">fieldDirectives</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span>
</span><span class="hll">            <span class="nx">dir</span> <span class="p">=&gt;</span> <span class="nx">dir</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="s2">&quot;private&quot;</span>
</span><span class="hll">          <span class="p">);</span>
</span><span class="hll">          
</span><span class="hll">          <span class="kr">const</span> <span class="p">{</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="nx">defaultFieldResolver</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">fieldConfig</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">          <span class="k">if</span> <span class="p">(</span><span class="nx">privateDirective</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">            <span class="nx">fieldConfig</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">info</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">              <span class="kr">const</span> <span class="nx">privateAuthorized</span> <span class="o">=</span> <span class="nx">privateDirective</span> <span class="o">&amp;&amp;</span> <span class="nx">context</span><span class="p">.</span><span class="nx">user</span><span class="o">?</span><span class="p">.</span><span class="nx">sub</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">privateAuthorized</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">                <span class="k">throw</span> <span class="k">new</span> <span class="nx">ApolloError</span><span class="p">(</span><span class="s2">&quot;Not authorized!&quot;</span><span class="p">);</span>
</span><span class="hll">              <span class="p">}</span>
</span><span class="hll">
</span><span class="hll">              <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">info</span><span class="p">);</span>
</span><span class="hll">            <span class="p">};</span>
</span><span class="hll">            
</span><span class="hll">            <span class="k">return</span> <span class="nx">fieldConfig</span><span class="p">;</span>
</span><span class="hll">          <span class="p">}</span>
</span>        <span class="p">}</span>
      <span class="p">})</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">authDirectives</span><span class="p">;</span>
</pre></div>

<p>We’ll test this code out in a moment, but first, we’ll add the <code>@owner</code> directive definition to <code>authDirectives.graphql</code>. This custom directive will take a non-nullable <code>String</code> argument that indicates where in the field arguments a reference to the ID of the resource’s owner may be found:</p>
<p></p>
<div class="code-context">
<p>shared/src/directives/authDirectives.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Singline"># ...</span>
<span class="hll">
</span><span class="hll"><span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="c c-Multi">Require an authenticated user to be the owner of the resource to use the field.</span>
</span><span class="hll"><span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="kt">directive</span> <span class="kt">@owner</span><span class="p">(</span>
</span><span class="hll">  <span class="c c-Multi">&quot;&quot;&quot;</span>
</span><span class="hll"><span class="c c-Multi">  Name of the argument to check against the access token&#39;s `sub` claim.</span>
</span><span class="hll"><span class="c c-Multi">  </span>
</span><span class="hll"><span class="c c-Multi">  Dot notation is allowed for nested fields.</span>
</span><span class="hll"><span class="c c-Multi">  &quot;&quot;&quot;</span>
</span><span class="hll">  argumentName: <span class="k">String</span><span class="p">!</span>
</span><span class="hll"><span class="p">)</span> <span class="kt">on</span> <span class="k">FIELD_DEFINITION</span>
</span></pre></div>

<p>In some cases, the owner ID argument may be nested inside of the <code>args</code> parameter in the resolver, so we allow dot notation in string form to represent the relationships in the <code>argumentName</code> argument above. To facilitate searching through the resolver’s <code>args</code> object using dot notation, we’ll install <code>lodash-es</code>:</p>
<p></p>
<div class="code-context">
<p>shared/</p>
</div>
<div class="highlight"><pre><span></span>npm i lodash-es@4.17.21
</pre></div>

<p>Specifically, we’ll need its <code>get</code> function:</p>
<p></p>
<div class="code-context">
<p>shared/src/directives/authDirectives.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="hll"><span class="kr">import</span> <span class="p">{</span> <span class="nx">get</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;lodash-es&quot;</span><span class="p">;</span>
</span><span class="c1">// ...</span>

<span class="kd">function</span> <span class="nx">authDirectives</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">authDirectives</span><span class="p">;</span>
</pre></div>

<p>Now we can build on our transformer function with logic to handle the <code>@owner</code> directive as well. The code that we add will verify that the submitted argument value matches the value of <code>context.user.sub</code>:</p>
<p></p>
<div class="code-context">
<p>shared/src/directives/authDirectives.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="kd">function</span> <span class="nx">authDirectives</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">__dirname</span> <span class="o">=</span> <span class="nx">dirname</span><span class="p">(</span><span class="nx">fileURLToPath</span><span class="p">(</span><span class="kr">import</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">url</span><span class="p">));</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">authDirectivesTransformer</span><span class="o">:</span> <span class="nx">schema</span> <span class="p">=&gt;</span>
      <span class="nx">mapSchema</span><span class="p">(</span><span class="nx">schema</span><span class="p">,</span> <span class="p">{</span>
        <span class="p">[</span><span class="nx">MapperKind</span><span class="p">.</span><span class="nx">OBJECT_FIELD</span><span class="p">]</span><span class="o">:</span> <span class="nx">fieldConfig</span> <span class="p">=&gt;</span> <span class="p">{</span>
          <span class="c1">// ...</span>
<span class="hll">          <span class="kr">const</span> <span class="nx">ownerDirective</span> <span class="o">=</span> <span class="nx">fieldDirectives</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span>
</span><span class="hll">            <span class="nx">dir</span> <span class="p">=&gt;</span> <span class="nx">dir</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="s2">&quot;owner&quot;</span>
</span><span class="hll">          <span class="p">);</span>
</span>          
          <span class="kr">const</span> <span class="p">{</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="nx">defaultFieldResolver</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">fieldConfig</span><span class="p">;</span>

<span class="hll">          <span class="k">if</span> <span class="p">(</span><span class="nx">privateDirective</span> <span class="o">||</span> <span class="nx">ownerDirective</span><span class="p">)</span> <span class="p">{</span>
</span>            <span class="nx">fieldConfig</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">info</span><span class="p">)</span> <span class="p">{</span>
              <span class="kr">const</span> <span class="nx">privateAuthorized</span> <span class="o">=</span> <span class="nx">privateDirective</span> <span class="o">&amp;&amp;</span> <span class="nx">context</span><span class="p">.</span><span class="nx">user</span><span class="o">?</span><span class="p">.</span><span class="nx">sub</span><span class="p">;</span>
<span class="hll">              <span class="kr">const</span> <span class="nx">ownerArgAuthorized</span> <span class="o">=</span>
</span><span class="hll">                <span class="nx">ownerDirective</span> <span class="o">&amp;&amp;</span>
</span><span class="hll">                <span class="nx">context</span><span class="p">.</span><span class="nx">user</span><span class="o">?</span><span class="p">.</span><span class="nx">sub</span> <span class="o">&amp;&amp;</span>
</span><span class="hll">                <span class="nx">get</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">ownerDirective</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">argumentName</span><span class="p">)</span> <span class="o">===</span>
</span><span class="hll">                  <span class="nx">context</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">sub</span><span class="p">;</span>
</span>
<span class="hll">              <span class="k">if</span> <span class="p">(</span>
</span><span class="hll">                <span class="p">(</span><span class="nx">privateDirective</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">privateAuthorized</span><span class="p">)</span> <span class="o">||</span>
</span><span class="hll">                <span class="p">(</span><span class="nx">ownerDirective</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">ownerArgAuthorized</span><span class="p">)</span>
</span><span class="hll">              <span class="p">)</span> <span class="p">{</span>
</span>                <span class="k">throw</span> <span class="k">new</span> <span class="nx">ApolloError</span><span class="p">(</span><span class="s2">&quot;Not authorized!&quot;</span><span class="p">);</span>
              <span class="p">}</span>

              <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">info</span><span class="p">);</span>
            <span class="p">};</span>
            
            <span class="k">return</span> <span class="nx">fieldConfig</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">})</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">authDirectives</span><span class="p">;</span>
</pre></div>

<p>The <code>@private</code> and <code>@owner</code> directives are now ready to go, so we can export them from the main entry point of the <code>shared</code> module:</p>
<p></p>
<div class="code-context">
<p>shared/src/index.js</p>
</div>
<div class="highlight"><pre><span></span><span class="hll"><span class="kr">import</span> <span class="nx">authDirectives</span> <span class="nx">from</span> <span class="s2">&quot;./directives/authDirectives.js&quot;</span><span class="p">;</span>
</span><span class="kr">import</span> <span class="nx">DateTimeType</span> <span class="nx">from</span> <span class="s2">&quot;./scalars/DateTypeType.js&quot;</span><span class="p">;</span>

<span class="hll"><span class="kr">export</span> <span class="p">{</span> <span class="nx">authDirectives</span><span class="p">,</span> <span class="nx">DateTimeType</span> <span class="p">};</span>
</span></pre></div>

<p>Now we’re ready to import the <code>authDirectives</code> function to use in the accounts service. To do that, we must concatenate the directive definitions to the rest of the subgraph’s type definitions and also apply the transformer function to the schema:</p>
<p></p>
<div class="code-context">
<p>accounts/src/index.js</p>
</div>
<div class="highlight"><pre><span></span><span class="c1">// ...</span>

<span class="hll"><span class="kr">import</span> <span class="p">{</span> <span class="nx">authDirectives</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;../../shared/src/index.js&quot;</span><span class="p">;</span>
</span><span class="c1">// ...</span>

<span class="hll"><span class="kr">const</span> <span class="p">{</span> <span class="nx">authDirectivesTypeDefs</span><span class="p">,</span> <span class="nx">authDirectivesTransformer</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">authDirectives</span><span class="p">();</span>
</span><span class="hll"><span class="kr">const</span> <span class="nx">subgraphTypeDefs</span> <span class="o">=</span> <span class="nx">readFileSync</span><span class="p">(</span>
</span><span class="hll">  <span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="s2">&quot;./graphql/schema.graphql&quot;</span><span class="p">),</span>
</span><span class="hll">  <span class="s2">&quot;utf-8&quot;</span>
</span><span class="hll"><span class="p">);</span>
</span><span class="hll"><span class="kr">const</span> <span class="nx">typeDefs</span> <span class="o">=</span> <span class="nx">gql</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">subgraphTypeDefs</span><span class="si">}</span><span class="err">\</span><span class="sb">n</span><span class="si">${</span><span class="nx">authDirectivesTypeDefs</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
</span><span class="hll"><span class="kd">let</span> <span class="nx">subgraphSchema</span> <span class="o">=</span> <span class="nx">buildSubgraphSchema</span><span class="p">({</span> <span class="nx">typeDefs</span><span class="p">,</span> <span class="nx">resolvers</span> <span class="p">});</span>
</span><span class="hll"><span class="nx">subgraphSchema</span> <span class="o">=</span> <span class="nx">authDirectivesTransformer</span><span class="p">(</span><span class="nx">subgraphSchema</span><span class="p">);</span>
</span>
<span class="kr">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ApolloServer</span><span class="p">({</span>
<span class="hll">  <span class="nx">schema</span><span class="o">:</span> <span class="nx">subgraphSchema</span><span class="p">,</span>
</span>  <span class="c1">// ...</span>
<span class="p">});</span>

<span class="c1">// ...</span>
</pre></div>

<p>Next, we’ll apply the <code>@private</code> directive to the <code>account</code> and <code>accounts</code> fields on the root <code>Query</code> type so that they may only be resolved for authenticated users:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/schema.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Singline"># ...</span>

<span class="kt">type</span> <span class="k">Query</span> <span class="p">{</span>
  <span class="s2">&quot;Retrieves a single account by ID.&quot;</span>
<span class="hll">  <span class="k">account</span><span class="p">(</span>id: <span class="k">ID</span><span class="p">!):</span> <span class="k">Account</span><span class="p">!</span> <span class="kt">@private</span>
</span>  <span class="s2">&quot;Retrieves a list of accounts.&quot;</span>
<span class="hll">  accounts: <span class="p">[</span><span class="k">Account</span><span class="p">]</span> <span class="kt">@private</span>
</span>  <span class="s2">&quot;Retrieves the account of the currently logged-in user.&quot;</span>
  viewer: <span class="k">Account</span>
<span class="p">}</span>

<span class="c c-Singline"># ...</span>
</pre></div>

<p>Try running one of these queries now with and without a valid JWT in the <code>Authorization</code> header. When the JWT is removed, you should see a similar error response:</p>
<p></p>
<div class="code-context">
<p>API Response</p>
</div>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;errors&quot;</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="s2">&quot;message&quot;</span><span class="o">:</span> <span class="s2">&quot;Not authorized!&quot;</span><span class="p">,</span>
      <span class="s2">&quot;extensions&quot;</span><span class="o">:</span> <span class="p">{</span>
        <span class="s2">&quot;code&quot;</span><span class="o">:</span> <span class="s2">&quot;INTERNAL_SERVER_ERROR&quot;</span><span class="p">,</span>
        <span class="s2">&quot;serviceName&quot;</span><span class="o">:</span> <span class="s2">&quot;accounts&quot;</span><span class="p">,</span>
        <span class="s2">&quot;exception&quot;</span><span class="o">:</span> <span class="p">{</span>
          <span class="s2">&quot;stacktrace&quot;</span><span class="o">:</span> <span class="p">[</span>
            <span class="s2">&quot;Error: Not authorized!&quot;</span><span class="p">,</span>
            <span class="c1">// ...</span>
          <span class="p">],</span>
          <span class="s2">&quot;message&quot;</span><span class="o">:</span> <span class="s2">&quot;Not authorized!&quot;</span><span class="p">,</span>
          <span class="s2">&quot;locations&quot;</span><span class="o">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="s2">&quot;line&quot;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
              <span class="s2">&quot;column&quot;</span><span class="o">:</span> <span class="mi">29</span>
            <span class="p">}</span>
          <span class="p">],</span>
          <span class="s2">&quot;path&quot;</span><span class="o">:</span> <span class="p">[</span>
            <span class="s2">&quot;accounts&quot;</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="s2">&quot;data&quot;</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">&quot;accounts&quot;</span><span class="o">:</span> <span class="kc">null</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>The final step for adding authorization to the accounts service will be using the <code>@owner</code> directive to ensure that an account can only be updated or deleted by the user that owns it:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/schema.graphql</p>
</div>
<div class="highlight"><pre><span></span><span class="c c-Singline"># ...</span>

<span class="kt">type</span> <span class="k">Mutation</span> <span class="p">{</span>
  <span class="s2">&quot;Creates a new account.&quot;</span>
  <span class="k">createAccount</span><span class="p">(</span>input: <span class="k">CreateAccountInput</span><span class="p">!):</span> <span class="k">Account</span><span class="p">!</span> 
  <span class="s2">&quot;Deletes an account.&quot;</span>
<span class="hll">  <span class="k">deleteAccount</span><span class="p">(</span>id: <span class="k">ID</span><span class="p">!):</span> <span class="k">Boolean</span><span class="p">!</span> <span class="kt">@owner</span><span class="p">(</span>argumentName: <span class="s2">&quot;id&quot;</span><span class="p">)</span>
</span>  <span class="s2">&quot;Updates an account&#39;s email.&quot;</span>
  <span class="k">updateAccountEmail</span><span class="p">(</span>input: <span class="k">UpdateAccountEmailInput</span><span class="p">!):</span> <span class="k">Account</span><span class="p">!</span>
<span class="hll">    <span class="kt">@owner</span><span class="p">(</span>argumentName: <span class="s2">&quot;input.id&quot;</span><span class="p">)</span>
</span>  <span class="s2">&quot;Updates an account&#39;s password.&quot;</span>
  <span class="k">updateAccountPassword</span><span class="p">(</span>input: <span class="k">UpdateAccountPasswordInput</span><span class="p">!):</span> <span class="k">Account</span><span class="p">!</span>
<span class="hll">    <span class="kt">@owner</span><span class="p">(</span>argumentName: <span class="s2">&quot;input.id&quot;</span><span class="p">)</span>
</span><span class="p">}</span>
</pre></div>

<p>Note that we use dot notation for the nested <code>id</code> value inside of the <code>input</code> field to indicate where the account owner ID can be found in the Input Object argument for the two update mutations. Now try running these mutations again using a valid JWT obtained for a different user. Again, you should see the <code>Not authorized!</code> error returned in the response.</p>
<h2 id="securing-references-resolvers">Securing References Resolvers</h2>
<p>Before we wrap up this chapter, we need to address a security hole related to accounts. As a best practice, only the gateway should be able to send requests to subgraph services in production environments. Under those conditions, bad actors shouldn’t be able to query account data by writing a query that includes the <code>_entities</code> field and then send that request to the subgraph directly. However, we must consider another scenario where a request sent from the gateway may lead to unauthorized access of the accounts data.</p>
<p>We made the <code>Account</code> Object type an entity, which means that it can be referenced and extended in other subgraph schemas. Thinking ahead to when we add additional subgraphs, if a subgraph exposes a publicly queryable field with an Object output type that in turn references the <code>Account</code> entity as an output type for one of its fields, then there will be no authorization checks when the <code>__resolveReference</code> resolver is executed for the <code>Account</code> type in the accounts service. Here is a hypothetical example to illustrate this point:</p>
<div class="highlight"><pre><span></span><span class="kt">type</span> <span class="k">SomePublicType</span> <span class="p">{</span>
  <span class="c c-Singline"># This field is publicly queryable</span>
  id: <span class="k">ID</span><span class="p">!</span> 
  <span class="c c-Singline"># This field should only be accessible to authenticated users</span>
  <span class="c c-Singline"># based on the requirements of the accounts service, but there</span>
  <span class="c c-Singline"># aren&#39;t any checks in place to authorize account access when</span>
  <span class="c c-Singline"># queried by the gateway via the `_entities` field</span>
  account: <span class="k">Account</span><span class="p">!</span>
<span class="p">}</span>

<span class="kt">type</span> <span class="k">Query</span> <span class="p">{</span>
  <span class="c c-Singline"># No authorization directive applied here</span>
  <span class="k">somePublicType</span><span class="p">(</span>id: <span class="k">ID</span><span class="p">!):</span> <span class="k">SomePublicType</span>
<span class="p">}</span>
</pre></div>

<p>Before we choose a solution to address this security issue, it’s worth pausing to reflect on the relative advantages and disadvantages of the approach we just took to configure field-level authorization for the accounts service. One clear advantage to using type system directives from a shared library is that it can help standardize how authorization is handled across subgraphs, or at least for any Node.js subgraphs at the moment. This can save subgraph maintainers from having to maintain their own authorization solutions and improve predictability on the client side. However, we can’t directly apply an <code>@private</code> or <code>@owner</code> directive to any of the fields that <code>buildSubgraphSchema</code> adds to our subgraph schema.</p>
<p>Alternatively, using resolver middleware such as GraphQL Shield or AuthZ in each subgraph may have provided more flexibility and nuance when adding field-level authorization, including reference resolvers. Additionally, resolver middleware prevents tight coupling of authorization logic to the subgraph’s type definitions, which may or may not be an important schema design consideration for your project. But of course, the trade-off is a potential loss of consistency and the requirement to implement these rules on a per-subgraph basis.</p>
<p>We’re going to stick with our directive-based approach for the Marked GraphQL API, so we have two options for authorizing access to an account via the reference resolver. The first would be to support the <code>OBJECT</code> location for the <code>@private</code> and <code>@owner</code> directives as well so that we can globally declare an authorization requirement for an Object type wherever it is used as an output type for the field. However, we will quickly run into new challenges where we need to handle fields within that object that may have more or less permissive authorization directives applied. Additionally, applying authorization directives directly to an entire Object type such as <code>Account</code> means that we would also need some way to override it to handle a field such as <code>viewer</code> where we merely return <code>null</code> if there’s no token in the context, or we would need to wrap <code>Account</code> in another type to use as an output type with this field instead.</p>
<p>Handling this kind of complex logic is outside the scope of this book, so we will opt for the second option which is to do one-off authorization checks directly in the reference resolvers for any entities that we define. This will be one of the key exceptions that we make when abstracting authorization logic into custom directives. Let’s update the reference resolver for the <code>Account</code> type now with a few additional lines of code to check for a <code>user</code> in the <code>context</code>:</p>
<p></p>
<div class="code-context">
<p>accounts/src/graphql/resolvers.js</p>
</div>
<div class="highlight"><pre><span></span><span class="hll"><span class="kr">import</span> <span class="p">{</span> <span class="nx">ApolloError</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;apollo-server&quot;</span><span class="p">;</span>
</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">DateTimeType</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;../../../shared/src/index.js&quot;</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">resolvers</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nx">Account</span><span class="o">:</span> <span class="p">{</span>
<span class="hll">    <span class="nx">__resolveReference</span><span class="p">(</span><span class="nx">reference</span><span class="p">,</span> <span class="p">{</span> <span class="nx">dataSources</span><span class="p">,</span> <span class="nx">user</span> <span class="p">})</span> <span class="p">{</span>
</span><span class="hll">      <span class="k">if</span> <span class="p">(</span><span class="nx">user</span><span class="o">?</span><span class="p">.</span><span class="nx">sub</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">        <span class="k">return</span> <span class="nx">dataSources</span><span class="p">.</span><span class="nx">accountsAPI</span><span class="p">.</span><span class="nx">getAccountById</span><span class="p">(</span><span class="nx">reference</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
</span><span class="hll">      <span class="p">}</span>
</span><span class="hll">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">ApolloError</span><span class="p">(</span><span class="s2">&quot;Not authorized!&quot;</span><span class="p">);</span>
</span>    <span class="p">},</span>
    <span class="c1">// ...</span>
  <span class="p">},</span>

  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">resolvers</span><span class="p">;</span>
</pre></div>

<p>Apart from the <code>Account</code> type, we only need to define one other entity in the Marked GraphQL API, so this approach will be manageable for now but could be revisited and optimized as warranted in the future as additional subgraphs are added to the federated graph.</p>
<h2 id="summary">Summary</h2>
<p>This chapter was an opportunity to pause and make our code a bit cleaner and more developer-friendly before adding additional subgraphs to the Marked GraphQL API. We started by adding an <code>AccountsDataSource</code> to extract explicit data-fetching logic from the accounts service’s resolvers. As we move forward and write the code for the other three subgraph services, we’ll add Apollo data sources from the start. We’ll also reuse the <code>DateTime</code> custom Scalar type and the <code>@private</code> and <code>@owner</code> custom type system directives across the different subgraph schemas. In the next chapter, we’ll build the first of the three remaining services—the profiles service.</p>
<footer>
<p class="copyright">Copyright © 2022 <a href="https://8bit.press/">8-Bit Press Inc.</a> All rights reserved.</p>
</footer>
</div>
</div>
<script>
(function () {
  "use strict";

  const chapter = document.getElementById("chapter");

  // Set width of fixed-position chapter navigation based on parent
  function setChapterNavWidth() {
    const chapterNav = document.getElementsByClassName("chapter-nav")[0];
    let { width: chapterWidth } = chapter.getBoundingClientRect();
    chapterNav.setAttribute(
      "style",
      `width: ${chapterWidth >= 960 ? chapterWidth * 0.3 + 36 + "px" : "100%"}`
    );
  }

  setChapterNavWidth();
  window.addEventListener("resize", setChapterNavWidth);

  // Open and close the book navigation in the masthead
  const openMastheadButton = document.getElementById("masthead-open");
  const closeMastheadButton = document.getElementById("masthead-close");
  const masthead = document.getElementById("masthead");

  openMastheadButton.addEventListener("click", function (event) {
    event.stopPropagation();
    masthead.style.marginLeft = "0px";
  });

  closeMastheadButton.addEventListener("click", function () {
    masthead.style.marginLeft = "-100%";
  });

  chapter.addEventListener("click", function () {
    if (masthead.style.marginLeft === "0px") {
      masthead.style.marginLeft = "-100%";
    }
  });

  // Add "Copy" button to code snippets
  // Reference: https://tomspencer.dev/blog/2018/09/14/adding-click-to-copy-buttons-to-a-hugo-powered-blog/
  if (!document.queryCommandSupported("copy")) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.textContent = msg;
    setTimeout(function () {
      el.textContent = "Copy";
    }, 1000);
  }

  function selectText(node) {
    const selection = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    const copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn";
    copyBtn.textContent = "Copy";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener("click", function () {
      try {
        const selection = selectText(codeEl);
        document.execCommand("copy");
        selection.removeAllRanges();

        flashCopyMessage(copyBtn, "Copied!");
      } catch (e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, "Failed :'(");
      }
    });

    containerEl.appendChild(copyBtn);
  }

  // Add copy button to code blocks
  var highlightBlocks = document.getElementsByClassName("highlight");
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>
</body>
</html>